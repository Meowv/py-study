{"title": "5个套路看懂微信小程序开发 ", "author": "Rolan", "pubtime": "2019-6-21 00:17", "content": "你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信小程序的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。在开始之前，先做100字的铺垫。一个页面 = 4个文件小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：js 文件——数据来源；wxml 文件——页面的骨架；wxss 文件——页面的装饰效果；json 文件——可选，配置页面上的零件。另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。部分语言过于通俗是为了更好的理解。绑定数据现在就开始我们的第一个套路。小程序简易教程 -> 编写代码 -> 创建页面 -> 第二个代码块依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js 文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 data），就是页面上需要用到的数据。这就叫做数据绑定。「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。声明的格式是这样的（类似上图中的内容）：Page({data: {greeting: 'Hello World'}//...})在微信开发工具中是这样的：注意看红框中的内容，和上面的代码块是一样的注意看 data 那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：{{greeting}}注意看{{ }}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。这就完成了我们的第一个套路——数据绑定。简单吧！但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？答案是我们的页面上，也就是 wxml 这个文件中。这就是我们的下一个套路——显示数据。显示数据上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：<text class=\"your-class\">{{greeting}}</text>在微信开发工具中的样子是这样的：还是看红框内的内容，也请注意这是在 wxml 文件中我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：最左边红框中的文字一点装饰效果都没有为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：标签样式表什么是标签，我们从例子中来理解：{{greeting}}两边的<text class=\"your-class\">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class=\"your-class\"就是<text>这个标签的一个属性，<text>标签会表现出class=\"your-class\"的规定的样子。那么class=\"your-class\"这个属性的完整意思是什么呢？他的意思是<text>的 class 对应样式表中的your-class。对，你可以把等号理解为对应。而后面的\"your-class\"就是我们在样式表中规定好的一种装饰效果。这里出现了我们的第2个工具：样式表。样式表是写在 wxss 文件中的，我们来看看怎么写：.your-class {display: flex;flex-direction: column;align-items: center;color: blue;}在开发者工具中的样子是这样的：你通过理解代码中英文的字面意思就可以了解到，我把字的 color 定义为蓝色，把位置定义为 center。最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class 属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 class 属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)到这里，我们的前两个套路就已经简单的介绍完了。总结一下：绑定数据：在 js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。显示数据：在 wxml 中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss 文件中写好。不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css 大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：Page({data: {greeting: 'Hello World',farewell: 'Goodbye!'}//其他内容})而对应显示这两个数据的示例代码是这样的：<!--index.wxml--><text class=\"your-class\">{{greeting}}</text><view class=\"your-class\">{{farewell}}</view>在开发者工具中显示的样子是这样的：我在写教程的过程中升级了一次开发者工具，所以界面有变化大家可以看到，我在最右侧的红箭头处加入了一行新代码， 然后显示出了新数据。但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml 文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。绑定交互绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。绑定交互分为两步：声明：在 js 文件中声明交互的名称。使用：在 wxml 文件中使用这个交互。先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）请在 js 文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}在开发者工具中的样子是：这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say Goodbye!。而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 wxml 中插入这样的代码片段：<button bindtap=\"changeWord\" type='primary' class=\"your-button\" size='default'>改变文字</button>在开发者工具中的的样子是这样的：这里的重点是bindtap=\"changeWord\"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 Never Say Goodbye!除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。你会发现他们的开头都是 bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。执行交互就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：changeWord: function() {// 这里写交互的实际内容}我们这里介绍两种交互内容的写法，足够解决很多问题了：修改页面数据弹窗第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}这几行代码中间的部分，就是要执行的交互内容：this.setData({farewell: 'Never Say Goodbye!'})即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 Never Say Goodbye!。如果你想修改其他数据，比如greeting，你可以如法炮制：changeAnotherWord: function() {this.setData({greeting: 'Hello, again!'})}你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: 'Hello, again!'）。如果你也想修改页面上的数据，请如法炮制。我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。声明交互的代码如下（在 js 文件中），我们用showConfirmation作为名称： showConfirmation: function() {\r\n var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n }\r\n在微信开发者工具中是这样的：先不要在乎这里面陌生的代码，我们继续看使用交互的部分：<button bindtap=\"showConfirmation\" type='primary' class=\"your-button\" size='default'>改变文字</button>我把上一个套路中出现的 button 改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：写完之后，我再去点「改变文字」的按钮，就会出现对话框：箭头连接的两部分是一样的，你发现了吗你会发现，所有的不一样，都只是在 js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码： var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：我们只需要像填空一样，把制作对话框需要的 title, content, showCancel 等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。但在这段代码中，有一个比较难解释的地方，就是var that = this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var that = this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：使用wx.showModal跳转到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。要跳转到下一个页面，我们只需要最后一个套路：跳转。跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。我们先在 js 文件中声明一个名为navigateToLogs的交互：navigateToLogs: function() {wx.navigateTo({url: '/pages/logs/logs'})}在开发者工具中的样子是这样的：这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。在 wxml 中使用这个交互：<button bindtap=\"navigateToLogs\" type='default' class=\"your-button\" size='default'>跳转</button>在开发者工具中的样子是这样的：好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。已经看完了效果，我们回来看那段不熟悉的代码：wx.navigateTo({url: '/pages/logs/logs'})这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs 路径下的页面（url: '/pages/logs/logs'）。其中 url 这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？大家看下图红框中的文件结构，会发现 logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。总结一下好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：绑定数据——在 js 文件中声明数据名称显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果绑定交互——在 js 文件中声明交互的名称执行交互——在 js 文件中支出要修改的数据或者显示弹窗跳转——跳转到下一页，开辟新的战场番外篇——调取微信数据微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。共勉。这种标记叫做选择器，可以在这个小程序 wxss 文档的选择器那一节找到而且是个简版的css，不会用到复杂一点的级联样式另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on 开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml 中绑定到标签。微信还有2个可用弹窗类交互，大家可以对照文档进行实验。微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。"}
{"title": "当微信小程序遇上 TensorFlow：本地缓存模型 ", "author": "Rolan", "pubtime": "2019-7-3 10:08", "content": "从明天开始，我开始休年假，准备去云南逛一逛，估计这段时间又无法更新公众号，还请大家谅解。在《 当微信小程序遇上TensorFlow - tensorflow.js篇 》一文中，我介绍了在微信小程序中使用TensorFlow.js，有朋友可能注意到，小程序每次都需要从网络加载模型。虽然tensorflow.js官方声称利用了浏览器的缓存技术，并不会每次都从网络下载。但在微信小程序中，使用的是wx.request接口下载文件，测试下来发现，似乎没有缓存机制。虽然小程序号称即用即走，但每次都需要从网络下载模型，完全体现不出端推断的优点，况且深度学习模型通常也不小，通常有好几M。那我们能否将模型存储到本地呢？查阅tfjs的文档，在浏览器中，提供了几种本地存储的方式：将模型保存到浏览器的local storage，后续可以从local storage加载将模型保存到浏览器的IndexDB，然后从IndexDB加载将模型通过下载方式保存到本地，然后可以通过文件上载方式加载模型微信小程序支持两种形式的本地存储：数据缓存和本地文件。为此，我参考了 browser_files.ts 的实现，实现了微信小程序平台下的本地文件存储 mp_files.ts 。具体代码可以参考：https://github.com/mogoweb/wechat-tfjs-core实现上并没什么特别的难度，但是栽在微信小程序的坑里，爬了好几天才找到原因。具体说来就是 FileSystemManager.readFile(Object object) 这个接口，不要想当然的认为将 encoding 设为 binary ，就会返回 ArrayBuffer 类型数据，文档对 encoding 参数的说明是：指定读取文件的字符编码，如果不传 encoding，则以 ArrayBuffer 格式读取文件的二进制内容所以为了以二进制字节读取文件内容，千万不要传 encoding 参数，否则永远返回的是 string 类型数据。至于模型保存，可以参考如下代码，为此我为小程序定义了一个 mp:// 前缀：const save_model = async model => {\r\n\r\n  const saveResult = await model.save('mp://' + wx.env.USER_DATA_PATH + '/mymodel');\r\n  console.log(saveResult);\r\n}加载模型，文件路径请指定正确的json和权重文件，无需加上 mp:// 前缀：const load_model = async () => {\r\n\r\n  let model_files = [wx.env.USER_DATA_PATH + '/mymodel.json', wx.env.USER_DATA_PATH + '/mymodel.weights.bin'];\r\n  var model = await tf.loadLayersModel(tf.io.mpFiles(model_files));\r\n  return model;\r\n}示例代码可以参考：https://github.com/mogoweb/wechat-tfjs-examples需要注意的是， 微信小程序对于本地文件总大小有10M的限制 ，所以这种方法只适合比较小的模型，如果那种几十M的深度学习模型，还是尽量部署到服务器。毕竟小程序的初衷就是小巧、轻便，如果过重，就背离了小程序的设计理念。"}
{"title": "微信小程序打怪之定时发送模板消息(node版) 方二山 ", "author": "Rolan", "pubtime": "2019-7-4 00:23", "content": "背景描述小程序答题签到功能，为了促进日活，需要每天定时向当日未签到的用户推送消息提醒签到。读本篇之前最好已经了解微信关于发送模板消息的相关文档:模板消息指南模板消息服务接口说明: 作者也是第一次写小程序的定时模板消息功能，作为一个纯种前端攻城狮，可能在建表操作数据库等后端代码上有不严谨或不合理的地方，欢迎大佬们拍砖指正(轻拍)。本文以提供解决思路为主，仅供学习交流，如有不合理的地方还请留言哦。 实现思路官方限制微信小程序推送模板消息下发条件:支付 当用户在小程序内完成过支付行为，可允许开发者向用户在 7天 内推送有限条数的模板消息 （1次支付可下发3条，多次支付下发条数独立，互相不影响）提交表单 当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在 7天 内推送有限条数的模板消息 （1次提交表单可下发1条，多次提交下发条数独立，相互不影响）根据官方的规则，显然用户1次触发7天内推送1条通知是明显不够用的，比如签到功能，只有用户在前一天签到情况下才能获取一次推送消息的机会，然后用于第二天向该用户发送签到提醒。倘若用户忘记了签到，系统便失去了提醒用户的权限，导致和用户断开了联系。如何突破限制？既然用户1次提及表单可以下发1条消息通知，且多次提交下发条数独立且互不影响。 那我们可以合理利用规则，将页面绑定点击事件的按钮都用form表单 report-submit=true 包裹 buttonform-type=submit 伪装起来，收集formId，将formId存入数据库中，然后通过定时任务再去向用户发送模板消息。开发步骤后台配置消息模板微信公众平台->功能->模板消息->我的模板中添加模板消息，如下:其中模板ID和关键词需要在发送模板消息的时候用到。数据库设计建表之前，思考一下都需要存哪些数据?根据微信的发送消息接口templateMessage.send可知，要给用户发送一条消息需要将touser(即用户的openid),form_id需要存入数据库。 另外获取用户form_id时的expire(过期时间)也需要存下来，另外还需要知道form_id是否使用以及过期的状态需要存一下。于是表的结构为:表: wx_save_form_idsqlCREATE TABLE `wx_save_form_id` (\r\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\r\n  `open_id` char(100) NOT NULL DEFAULT '',\r\n  `user_id` int(11) NOT NULL,\r\n  `form_id` char(100) NOT NULL DEFAULT '',\r\n  `expire` bigint(20) NOT NULL COMMENT 'form_id过期时间(时间戳)',\r\n  `status` int(1) DEFAULT '0' COMMENT '0 未推送 1已推送 2 过期',\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=114 DEFAULT CHARSET=utf8;表建好了，来捋一捋逻辑:用户提交表单，将open_id,user_id(根据自身需求存此字段),form_id，expire 以及status=0插入到wx_save_form_id表中开启定时任务(比如每天10:00执行)，到固定时间查询表wx_save_form_id，拿到status=0的数据，然后再调微信的templateMessage.send接口给对应的用户发送提示信息发送完的用户将status字段更新为1，下次查询的时候讲筛选掉已发送的状态。想想是不是漏掉点什么?一条form_id的过期时间是7天，那如果过期了怎么去将状态改完已过期呢？一个解决办法是，再开一个定时任务(比如20min执行一次)，去查询哪条form_id已经过期，然后再更改状态。如果数据只存在wx_save_form_id一张表中感觉效率会很低，不方便，也不合理。于是想到再去建立一张表:表: wx_message_push_statussqlCREATE TABLE `wx_message_push_status` (\r\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) NOT NULL,\r\n  `count` int(11) NOT NULL DEFAULT '1' COMMENT '可推送消息次数',\r\n  `last_date` bigint(20) NOT NULL DEFAULT '0' COMMENT '最后一次推送消息时间',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `user_id` (`user_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;其中 user_id(根据自身需求，也可以是open_id) 用户id, count 可向用户推送消息的次数 last_date 上一次推送消息的时间，用来判断当天是否再推送再重新捋一捋逻辑:用户提交表单，将open_id,user_id(根据自身需求存此字段),form_id，expire 以及status=0插入到wx_save_form_id表中，同时将wx_message_push_status表中的count自身+1开启定时任务(比如每天10:00执行)，到固定时间查询表wx_message_push_status，通过筛选条件 count>0且last_date不为当天，拿到可以推送消息的user_id再去查询wx_save_form_id表查询条件user_id=上面拿到的，status=0, expire >= 当前时间戳，然后再调微信的templateMessage.send接口给对应的用户发送提示信息发送完的用户将status字段更新为1，下次查询的时候讲筛选掉已发送的状态。开启另一个定时任务(比如间隔20分钟执行一次)，先去查询wx_save_form_id,筛选条件status=0且exprie<当前时间戳(即未发送，且过期的数据)将筛选到的数据status改为2，且查询wx_message_push_status表对应的user_id，将count自身减1。完美结束。理清开发逻辑，就准备动手写码代码实现前端页面页面的 form 组件，属性 report-submit 为 true 时，可以声明为需要发送模板消息，此时点击按钮提交表单可以获取 formIddemo.wxml<form report-submit=\"true\" bindsubmit=\"uploadFormId\">\r\n    <button form-type=\"submit\" hover-class=\"none\" >提交</button>\r\n</form>可以将页面中的绑定事件都用form组件来伪装，换取更多的formId。注: 获取form_id必须在真机上获取，模拟器会报the formId is a mock one;demo.jsPage({\r\n    ...\r\n    uploadFormId(e){\r\n        //上传form_id 发模板消息\r\n        wx.request({\r\n            url: 'xx/xx/uploadFormId',\r\n            data: {\r\n                form_id: e.detail.formId\r\n            }\r\n        });\r\n    }\r\n    ...\r\n})服务端接口server.js //node中间层 去调底层接口async updateFormIdAction(){\r\n    /*\r\n     *我们的userId和openId是存在server端，不需从前端传回。\r\n     *不必纠结接口的实现语法，和自身框架有关。\r\n     */\r\n    const {ctx} = this;\r\n    const user = ctx.user;\r\n    const userId = user ? user.userId : '';\r\n    const loginSession = ctx.loginSession;\r\n    const body = ctx.request.body;\r\n\r\n    let openId = loginSession.getData().miniProgram_openId || '';\r\n\r\n    const result = await this.callService('nodeMarket.saveUserFormId', openId, userId, body.form_id);\r\n    return this.json(result);\r\n}底层接口以及定时任务service.js //Node 操作数据库接口const request = require('request');\r\n\r\n/*\r\n * 根据用户userId openId 保存用户的formId\r\n * 存储formId的表 wx_save_form_id\r\n */\r\nasync saveUserFormIdAction(){\r\n    const http = this.http;\r\n    const req = http.req;\r\n    const body = req.body;\r\n\r\n    //7天后过期时间戳\r\n    let expire = new Date().getTime() + (7 * 24 * 60 * 60 *1000); \r\n    const sql = `INSERT INTO wx_save_form_id (open_id, user_id, form_id, expire) VALUES(${body.openId}, ${body.userId}, ${body.formId}, ${expire}) `;\r\n    //自行封装好的mysql实例 \r\n    let tmpResult = await mysqlClient.query(sql);\r\n    let result = tmpResult.results;\r\n    if (! result || result.affectedRows !== 1) {\r\n        ...\r\n    }\r\n\r\n    await this._updateMessagePushStatusByUserId(body.userId);\r\n    return this.json({\r\n        status: 0,\r\n        message: '成功'\r\n    });\r\n}\r\n\r\n// 更新用户可推送消息次数\r\n_updateMessagePushStatusByUserId(user_id){\r\n    const http = this.http;\r\n    try{\r\n        const selectSql = `SELECT user_id, count from wx_message_push_status WHERE user_id = ${user_id}`;\r\n        let temp = await mysqlClient.query(sql);\r\n        let result = temp.results;\r\n        if(result.length){\r\n            //有该user_id的记录 则更新数据\r\n            const updateSql = `UPDATE wx_message_push_status SET count = count + 1 WHERE user_id = ${user_id}`;\r\n            await mysqlClient.query(sql);\r\n            ...\r\n        }else {\r\n            //无记录 则插入新的记录\r\n            const insertSql = `INSERT INTO wx_message_push_status user_id VALUES $(user_id)`;\r\n            await mysqlClient.query(sql);\r\n            ...\r\n        }\r\n    }catch(err){\r\n        ...\r\n    }\r\n}\r\n\r\n//发送消息的定时任务\r\nasync sendMessageTaskAction(){\r\n    const http = this.http;\r\n    const Today = utils.getCurrentDateInt(); //当天日期 返回YYYYMMDD格式 具体实现忽略\r\n    //筛选count>0 且当天没有推送过的user_id\r\n    const selectCanPushSql = `select user_id from wx_message_push_status WHERE count > 0 AND last_date != ${Today}`;\r\n    let temp = await mysqlClient.query(selectCanPushSql);\r\n    let selectCanPush = temp.results;\r\n\r\n    if(selectCanPush.length){\r\n        selectCanPush.forEach(async (record)=>{\r\n            try{\r\n                let user_id = record.user_id;\r\n                //筛选出 status = 0, 且formId未过期 且 过期时间最近的数据\r\n                const currentTime = new Date().getTime();\r\n                const getFormIdSql = `select open_id, user_id, form_id from wx_save_form_id WHERE user_id = ${user_id} AND status = 0 AND expire >= ${currentTime} AND form_id != 'the formId is a mock one' ORDER BY expire ASC`;\r\n                let getFormIdTemp = await mysqlClient.query(getFormIdSql);\r\n                //获取可用的form_id列表\r\n                let getUserFormIds = getFormIdTemp.results;\r\n                //取出第一条可用的formId记录 发送消息\r\n                const { open_id, form_id } = getUserFormIds[0];\r\n                let sendStatus = await this._sendMessageToUser(open_id, form_id);\r\n                /*\r\n                 *发送完消息之后\r\n                 * 无论成功失败 将这条form_id置为已使用 最后推送时间为当天\r\n                 * 将可发消息次数减1\r\n                 */\r\n                let updateCountSql = `UPDATE wx_message_push_status SET count = count - 1, last_date = ${Today} WHERE count >0 AND user_id = ${user_id}; ` ;\r\n                await mysqlClient.query(updateCountSql);\r\n\r\n                let updateStatusSql = `UPDATE wx_save_form_id SET status = 1 WHERE user_id = ${user_id} AND open_id = ${open_id} AND form_id = ${form_id}`;\r\n                await mysqlClient.query(updateStatusSql);\r\n                ...\r\n            }catch(err){\r\n                ...\r\n            }\r\n        });\r\n    }\r\n    this.json({\r\n        status: 0\r\n    });\r\n}\r\n\r\n//发送模板消息\r\n_sendMessageToUser(open_id, form_id){\r\n    let accessToken = await this._getAccessToken();//获取token方法省略\r\n    const oDate = new Date();\r\n    const time = oDate.getFullYear() + '.' + (oDate.getMonth()+1) + '.' + oDate.getDate();\r\n    if(accessToken){\r\n        const url = `https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=${accessToken}`;\r\n        request({\r\n            url,\r\n            method: 'POST',\r\n            data: {\r\n                access_token,\r\n                touser: open_id,\r\n                form_id,\r\n                page: 'pages/xxx/xxx',\r\n                template_id: '你的模板ID',\r\n                data: {\r\n                    keyword1: {\r\n                        value: \"日领积分\"\r\n                    },\r\n                    keyword2: {\r\n                        value: '已经连续答题N天，连续答题7天有惊喜，加油～'\r\n                    },\r\n                    keyword3: {\r\n                        value: \"叮！该签到啦~锲而不舍,金石可镂。\"\r\n                    },\r\n                    keyword4: {\r\n                        value: time\r\n                    }\r\n                }\r\n            }\r\n        },(res)=>{\r\n            ...\r\n        })\r\n    }\r\n}\r\n\r\n/*\r\n * 检查wx_save_form_id表中的 expire字段是否过期，如果过期则将status 置为2 并且\r\n * 对应的 wx_message_push_status表中的count字段减1\r\n */\r\n async amendExpireTaskAction(){\r\n    let now = new Date().getTime();\r\n    try {\r\n        //筛选已经过期且未使用的记录\r\n        const expiredSql = `select * from wx_save_form_id WHERE status = 0 AND expire < ${now}`;\r\n        let expiredTemp = await mysqlClient.query(expiredSql);\r\n        let expired = expiredTemp.results;\r\n        if (expired.length){\r\n            expired.forEach(async (record)=>{\r\n                //将过期的记录状态更新我为2\r\n                const updateStatusSql = `UPDATE wx_save_form_id SET status = 2 WHERE open_id = '${record.open_id}' AND user_id = ${record.user_id} AND form_id = '${record.form_id}' `;\r\n                await mysqlClient.query(updateStatusSql);\r\n\r\n                //将推送次数减1\r\n                let updateCountSql = `UPDATE wx_message_push_status SET count = count - 1 WHERE count >0 AND user_id = ${record.user_id}; ` ;\r\n                await mysqlClient.query(updateCountSql);\r\n            });\r\n        }\r\n\r\n    }catch (e) {\r\n    }\r\n    this.json({\r\n        status: 0\r\n    });\r\n }执行定时任务发送消息呼~ 完整代码码完了。 大概思路是这样的，操作数据库没有考虑性能问题，如果数据量大会出现的问题，也没有考虑事务，索引等操作(主要是不会T_T),读者可以自行优化。最后需要开两个定时任务分别执行sendMessageTask接口和amendExpireTask接口，我们的定时任务也是找的开源的node框架，具体实现不陈述。最终效果:参考文献突破微信小程序模板消息限制，实现无限制主动推送人人贷大前端技术博客中心最后广而告之。 欢迎访问人人贷大前端技术博客中心里面有关nodejs react reactNative 小程序 前端工程化等相关的技术文章陆续更新中,欢迎访问和吐槽~上一篇: 小程序打怪之在线客服自动回复功能(node版)上上一篇: 微信小程序踩坑指南"}
{"title": "基于小程序技术栈的微信客户端跨平台实践 ", "author": "Rolan", "pubtime": "2019-7-4 00:41", "content": "https://gmtc2019.geekbang.org/presentation/1711一、前言小程序自诞生以来，经过两年多的发展，成为了微信开发者生态中最具有生命力的一环，为外部开发者开辟了全新的想象空间。然而，小程序带来的改变绝不仅限于微信之外，小程序技术栈的确立，又对微信客户端的研发产生了怎样的影响？二、微信客户端的跨平台实践微信客户端团队，早在 2012 年的时候就已经开始使用跨平台技术进行研发，从最初为了应对多平台客户端代码逻辑不统一的问题，到后续面向业务和 UI 开发，一直在尝试研发跨平台的解决方案。最早的跨平台组件是基于 C99 开发的 mmnet，在 2012 年 10 月份的时候为了解决多平台客户端出现的一系列不一致问题而打造的基础网络组件，后续经过不断的迭代优化，尤其是在应对弱网络做了深度的优化，并且加入了安全、容灾等各种网络策略。 mmnet 的通用部分逻辑代码于 2016 年以 mars 的名字在 github 开源，在业界获得了广泛的认可，完成了一个内部实验的跨平台组件到最终升华为所有人可用的开源项目 。同样在 github 受到欢迎的还有相似思路完成的 wcdb、mmkv 等跨平台组件。在完成基础组件的跨平台之后，随之而来的是面向业务和 UI 开发的跨平台尝试 。为了面对内部快速变化的创新业务，微信客户端团队不得不去寻求在多端上快速迭代的开发模式。在业务开发的过程中，能否可以做到像使用基础跨平台组件那样，只写一次代码就能在多端上得到体验一致的 UI 功能界面呢？在尝试了不同的方案之后，我们将目光放到了小程序上。 在微信小程序快速发展的两年内，各内部业务团队开始基于小程序去做创新业务的开发。借助微信小程序框架，这些业务可以获得相比于纯原生客户端开发周期短、上线快的优势，同时可以满足较强的运营需求。这种基于微信小程序的业务开发模式在内部逐渐的受到认可。我们认为好的跨平台开发模式必须要达到以下的 四个目标 ：减少平台差异性 ：应该最大限度减少不同平台上开发的差异性，尽可能减少各平台特有的开发负担；提高研发效率 ：从研发效率的角度看，在提高人效比的同时，应该尽可能提升开发人员在开发过程中的效率，包括编码、调试、运行、测试等多个环节；原生的性能和体验 ：从最终的研发产物看，应该有和分平台原生技术开发一样的性能表现和用户体验，让用户无法感知出差距；易学的可控技术栈 ：跨平台的技术栈应该具有较好的学习曲线，能够让更多原生开发的同学快速学习并掌握，且无论从技术还是商业角度看，都应该是可控、安全的技术栈。三、小程序与微信客户端 微信小程序采用了以前端技术栈为主的方案，框架上面抹平了许多平台差异性，同时业务也可以随时动态部署更新，而体验和性能也比较接近原生。随着小程序生态的发展，还出现了更多丰富的插件扩展机制、自定义组件机制和第三方开发框架。同时，小程序作为微信团队内部自主研发的框架，小程序已经是一个非常优秀的跨平台框架，满足一般的业务开发是没有问题的。然而，当我们以“小程序技术栈作为客户端跨平台开发技术”这一命题展开，关注其中的一些细节时，也发现了问题。附近的餐厅就是微信团队内部基于小程序开发的一个类似原生体验的业务。通过小程序实现了一次开发运行在 iOS、Android 两个客户端上的功能。整个开发的过程都主要以微信小程序的开发工具和开发标准为主，配合客户端实现部分额外增补能力，在基本功能完成之后我们也发现了一些在 Android 平台上出现的问题，这里举两个比较典型的例子。第一个是字体一致性体验问题。微信小程序使用 WebView 渲染，与原生客户端的是两套不同的视图渲染体系，在 Android 平台上出现了无法跟随系统字体保持一致的问题，体验上会有较为明显的割裂感。第二个在大量的图片和视频混排的场景下，会出现一些掉帧现象，在 Android 中低端机上较为明显。如下图所示，在图片滑动等连续过程中，会偶尔出现 LAG 的情况。并且受目前小程序框架所限，视频、图片的全屏显示效果也不够理想。正是因为 微信小程序框架在面对复杂业务的场景下还会存在一些体验和性能不尽人意的地方，在性能和体验上虽然 接近原生，但仍不能达到原生体验效果 ，我们决定针对这些细节尝试进行一步步的优化。先来看看小程序目前的系统架构。四、基于小程序技术栈的跨平台开发微信小程序的系统架构相信今天大部分的读者都比较熟悉了，总体来讲分为两部分：View 视图端通过小程序的框架将用户采用 WXML 和 WXSS 描述的UI信息处理成 H5 元素，最终交给 WebView 去渲染；App Service 端运行用户编写的 JavaScript 逻辑，并且可以调用具有微信开放能力的 JSAPI。逻辑和视图分离，通过事件和数据彼此之间建立联系。回到我们上面的问题， 在中低端机和稍复杂的业务上，受制于 Web 庞大而复杂的体系，要达到原生视图体系这样简单设计的体验，难度很高。 那么是否能够使用平台原生的视图渲染体系来解决问题呢？1. 基于原生渲染优化原理上我们可以将用户描述的 UI，转换成系统原生的组件，行业里面早有实践，受到 ReactNative 这类框架的启发，我们将小程序的视图端进行了一些改造，在 Android 平台上我们 dump 出小程序框架中 Virtual DOM 的信息和所有的 CSS 样式，在 Java 层逐一的去解析映射成原生的组件。但原生体系并不能完全的表达过于复杂的 CSS 样式，因此前期只支持了部分的 WXSS 特性。2. LV-CPP我们初步方案当中有太多的实现一开始是用 Java 去做的，考虑平台兼容问题，为了方便移植到其他平台以及可以更低成本的更换渲染模块，我们就将原来解析 DOM 和 CSS 样式的实现单独抽离了出来，形成一个独立的跨平台模块。最终选择了 C++ 实现的 LV-CPP 模块， 由 LV-CPP 去做跨平台的小程序 UI 体系处理器，完成 DOM 和 CSS 的解析、布局计算， 同时执行 JS 的功能由 V8 或者 JSCore 来完成。当 WXML/WXSS 描述的 UI 发生改变时，小程序前端公共库（WXA Framework）通过内部计算，将 Virtual DOM 树 Diff 的结果 以操作指令的形式提交到 LV-CPP。 LV-CPP 接收指令后，更新相应的节点，进行 CSS 的匹配、CSS 属性的转换以及布局的计算，计算好之后再调用 Native View 进行界面的渲染。CSS 匹配上，目前支持了 ID 选择器(#id)、标签选择器(button)、类选择器(.class)、组合选择器(A,B、A B、A>B、A+B、A~B)。为了提高性能，其中组合选择器的匹配使用了 WebKit 的逆序解析方案。之所以在 LV-CPP 中进行 CSS 属性的转换以及布局计算，目的是为了尽量抹平以后即使使用不同的渲染模块所带来的属性和布局上的差异。最典型的是颜色的转换。CSS 中颜色有各种表示方法，最常见的有：十六进制颜色，如：#0000ffRGB 颜色，如：rgb(0,0,255)RGBA 颜色，如：rgba(255,0,0,0.5)HSL 颜色，如：hsl(120,65%,75%)HSLA 颜色，如：hsla(120,65%,75%,0.3)颜色名，如：black这些不同种类的颜色表示方式，经过 LV-CPP 计算后输出的全部是十进制的颜色值，再交由渲染模块进行渲染。采用原生组件的方案确实在体验和性能方面能够带来不错的提升，在 Pixel 2 XL 的机器上我们测出，帧率方面比 WebView 提升了 27.5%，内存也可以下降 14%~23%。但随着我们要将该方案推广到各平台的时候，我们意识到需要在各个平台去做适配是一个巨大工作量的事情，而且后续的维护成本也将无法预测。基于 Web 的渲染满足不了性能和体验的要求，基于原生渲染又会带来高维护成本问题，我们需要一个跨平台的渲染方案来解决。 在研究各种可能的方案的时候，Flutter 再次走进了我们的视野。3. FlutterFlutter 是 Google 为跨平台打造的高性能应用框架，受到了很多同行的关注，但如果按照我们设定的微信跨平台开发的目标来看，Flutter 并不完全符合，使用 Dart 开发会对现有开发同学造成额外的学习成本，所以一开始我们并没有将 Flutter 作为客户端跨平台开发的候选。但 当我们的问题重新设定为“寻找一个跨平台的高性能渲染框架”时，Flutter 就逐渐体现出了各项优势 。从一些经典的 Benchmarks 案例中看到，Flutter 具有非常不错的性能水平。这组数据是我们在 ARM 平台测出的 Java，Dart JIT 和 Dart AOT 的对比数据，数值越高表示性能越好。同时另一个有意思的情况是，随着 Flutter 版本的提升，性能表现会越来越好，也说明 Flutter 的开发人员在不断地优化性能表现。而且从 Benchmarks Game 上能获取到和 JavaScript 的一些对比数据，从中大概能得出一个结论：Dart 的语言性能是超过 JavaScript，和 Java 有得一拼的。可以看下官方对 Flutter 的介绍：快速开发：Flutter 的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。富有表现力，漂亮的用户界面：自带的 Material Design 和 Cupertino（iOS风格）widget、丰富的 motion API、平滑而自然的滑动效果。响应式框架：使用 Flutter 的现代、响应式框架，和一系列基础 widget，轻松构建您的用户界面。访问本地功能和 SDK：Flutter 可以复用现有的 Java、Swift 或 ObjC代码，访问 iOS 和 Android 上的原生系统功能和系统 SDK。统一的应用开发体验：Flutter 拥有丰富的工具和库，可以帮助开发者轻松地同时在 iOS 和 Android 系统中实现想法和创意。原生性能：Flutter 包含了许多核心的 widget，如滚动、导航、图标和字体等，这些都可以在 iOS 和 Android 上达到原生应用一样的性能。在一系列的评估基础上，我们觉得可以使用 Flutter 去尝试一下。于是我们提出了 基于 Flutter 的小程序框架渲染优化方案 。4. 基于 Flutter 渲染优化我们把渲染部分由原来的平台原生组件替换成了 Flutter 的 Widgets，依然只支持精简后的 WXML 和 WXSS。在这个架构下，我们就将 Layout 层的 LV-CPP 专门的作为小程序的 UI 体系处理器，将 UI 信息布局计算好再提交给抽象的后端去渲染，LV-CPP 作为小程序的框架和渲染器的中间层，集中的在 C++ 层去处理与 Web 相关的复杂特性。渲染端就可以基于特定的协议和接口专注将元素转化为 UI 组件，最终绘制出来。通过结合 Flutter 和 LV-CPP，我们把实现代码收敛在 C++ 和 Dart 上，进一步简化了基于小程序技术栈实现跨平台业务开发的框架维护成本。然而，真正实现的过程中我们还得做更多的思考和优化。5. 通信难题小程序的框架是使用 JavaScript 再加上一些平台注入的接口来实现的，它们是运行在 JS Engine 的环境当中。而 Layout 层是采用 C++ 来实现，如何去解决 JavaScript 和 C++ 的互相通信问题呢？LV-CPP 在 C++ 层计算好布局之后，又如何将这些信息传递给渲染后端 Flutter 的 Dart 环境中呢？要想保障框架的性能，那么我们就必须要去解决两个问题。a. JS 的通信基于 Android WebView 的体系下可以在 Java 层通过 WebView 提供的接口注入一个 JavaScriptInterface，JS 就可以得到一个扩展的 API，调用的时候经过 V8 最终反射到 Java 上面。在 iOS 上面也是类似的实现， 这种方式第一是会带来平台相关性的实现；第二是调用路径较长。所以在这个问题上，我们最终使用了 JS Binding 的方案，将原先依赖平台的实现直接下沉到 C++，去实现 JS 对象的扩展，既可以解决跨平台的问题也能带来性能的提升。b. Flutter 的通信Flutter 官方提供了一种 Platform Channel 的方案，用于 Dart 和平台之间相互通信。主要的原理就是将传递的数据编码成消息的形式，跨线程发送到平台接口层，处理之后再将返回的数据通过同样的方式原路返回。基于消息和跨线程的处理使得这种方式的通信效率并不高，我们在骁龙845的机器上测了一组数据，一秒内通过 Platform Channel 只能大概完成四千次左右的相互调用。所以我们对 Flutter Engine 进行了一些改造，增加了一个 dart2cpp 的模块，暴露出部分的 C++ 接口，使得外部的动态库可以基于这些接口通过 DartVM 调用到 dart 的接口。在 Dart 的运行环境中 C++ 和 Dart 之间就可以像调用自身的接口一样调用彼此的接口。而且 在 AOT 模式下 Dart 会被编译成机器码，所以 C++ 和 Dart 的调用会非常的高效。 不需要将数据编码成消息和跨线程一系列的复杂流程，而是直接在内存栈上操作数据 。dart2cpp 相比于 Platform Channel 的方案提升多少呢，同样的测试案例，一秒内通过 dart2cpp 可以完成三十多万次的相互调用，可以说是极大的提升了通信效率。c. dart2cpp 实现原理DartVM 提供了一种机制，可以在 Dart 的代码中使用 native 关键字来表示调用的是一个 C/C++ 的接口。// Dart 示例代码bool systemSrand(int seed) native \"SystemSrand\";但这个 C/C++ 接口必须要先注册到 DartVM 当中，不然就无法查找到符号。DART_EXPORT Dart_HandleDart_SetNativeResolver(Dart_Handle library,Dart_NativeEntryResolver resolver,Dart_NativeEntrySymbol symbol);注册可以通过 Dart_SetNativeResolver 来完成，在 Dart 的运行过程中会通过注册的 Dart_NativeEntryResolver  根据函数信息来查找到 C/C++ 的函数地址。通过以上的两步就可以在 Dart 直接调用一个扩展的 C/C++ 函数，但是还没完，Dart 的内存模型和 C/C++ 的是有区别的，Dart 调到 C/C++ 的过程中传递的参数和函数返回值都使用了一个 Dart_NativeArguments 来描述，可以通过 Dart_GetNativeArgument/Dart_SetReturnValue   这两个接口来从 Dart_NativeArguments   上获取参数和设置返回值。// C++ 示例代码void SystemSrand(Dart_NativeArguments arguments) {Dart_EnterScope();bool success = false;Dart_Handle seed_object = HandleError(Dart_GetNativeArgument(arguments, 0));if (Dart_IsInteger(seed_object)) {bool fits;HandleError(Dart_IntegerFitsIntoInt64(seed_object, &fits));if (fits) {int64_t seed;HandleError(Dart_IntegerToInt64(seed_object, &seed));srand(static_cast<unsigned>(seed));success = true;}}Dart_SetReturnValue(arguments, HandleError(Dart_NewBoolean(success)));Dart_ExitScope();}d. cpp2dart 实现原理以上介绍了 Dart 调用 C/C++ 接口的实现原理，那么在 C/C++ 如何的调用 Dart 的接口呢，别急，在 DartVM 中依然可以找到解决办法。DART_EXPORT DART_WARN_UNUSED_RESULT Dart_HandleDart_Invoke(Dart_Handle target,Dart_Handle name,int number_of_arguments,Dart_Handle* arguments);可以在 dart_api.h 中找到一系列 API ，这些 API 就可以在 C/C++ 层操作到 Dart 的接口甚至是变量。有了这些基础的 API 就基本上可以做到 Dart 和 C/C++ 之间相互调用，但你可能还需要知道一些 DartVM 的执行机制，才能让你的代码正常的 work。上面的 C/C++ 的示例代码中，使用了 Dart_EnterScope/Dart_ExitScope 这么两个 API，事实上在 C/C++ 持有的 Dart 对象都是用 Dart_Handle 句柄来描述的，我们在函数内创建的很多变量都是局部变量，在离开作用域之后应该释放内存，那么 Scope 的概念就相当告诉 DartVM 当前创建的都是局部变量，在 ExitScope 之后应该回收这里用到的内存。当然还有一个重要的概念是 Isolate，Dart 的代码是运行在一个独立的 Isolate 当中的，在 Flutter 的体系当中，这个主 Isolate 一般是寄生在 UI Runner 的线程中，在 C/C++ 去调用 Dart 的接口必须要在 Isolate 的环境当中，不然就会出现各种异常。这里就涉及到非常多细节以及繁琐的 API 调用的问题，对一般的开发者开讲他只是要去调用一个外部的接口而已，可能不了解这些具体的技术细节，因此我们才开发了 dart2cpp 这么一套东西，使得开发者能够正常的写 Dart 和 C/C++ 的代码，不需要去关注数据如何的传递、Scope 以及 Isolate 这些细节。而且我们也不希望最终业务的动态库和 Flutter Engine 的动态库是绑定在一起的，它们可以是相互独立的动态库，在需要用到的时候，只需要通过 Dart 的接口去加载这个动态库，然后动态库将自己的信息注册到 Flutter Engine 当中，就可以做到 Dart 和外部动态库之间的 C/C++ 相互调用。e. js2dart这两套解决方案呢，其实它的想象空间绝非仅此，既然 JS 可以和 C++ 相互调用，C++ 又可以和 Dart 相互调用，他们结合在一起其实就可以间接的打通 JavaScript 和 Dart。虽然 JavaScript 和 Dart 有各自的执行环境和机制，但 通过 C++ 的桥梁，依然可以构建一个高效的通道 ，中间可以通过引用和一些转换(类似 JNI)来完成大多数的调用操作和数据传递。另外，Flutter 在动态部署（Hot Patch）方面虽然没有提供官方的支持，但是在借助于 js2dart 下能够做的事情就很多了，但这并不在本文的讨论范围。至此不同语言环境中的调用通信问题有了比较高效的解决方案 。6. Flutter 渲染优化后的小程序整体架构来看一下到目前为止小程序的整体架构调整。App Service 端依然保持原有的结构，处理用户编写的 JavaScript 逻辑；而视图端（PageView）则重新划分为四个层级，除了原有的 UI DSL 描述（WXML/WXSS）、小程序前端公共库（WXA Framework）外，还有由 LV-CPP 为主的 UI 布局处理层（Layout+）和 Flutter 实现的渲染层（Renderer）。使用简化的 WXML/WXSS 描述的 UI 信息，经过小程序前端公共库处理成 DOM 描述，通过 JS Binding 接口传递给 LV-CPP去解析 CSS 和 DOM 节点（Layout+）。LV-CPP 在完成布局计算之后将元素信息通过 dart2cpp 的接口发送到 Flutter 端，Flutter Framework 层直接将布局计算好的元素描述成渲染节点，交给 Flutter Engine 去绘制。整体上来讲我们把代码收敛在 Java Script，C++ 和 Dart 上，所以在跨平台方面会极大减少额外的负担。对小程序的开发者也不会带来任何的改变，面向开发者的依然是原有的小程序技术体系。7. 从 RN-like 到 Flutter 渲染从最初的 RN-like 方案再到基于 Flutter 方案的研究，本质上都只是在不断的解决我们遇到的问题，对比 Web 的方案体验和性能也都有提升，而且在平台维护方面也得到解决。汇总 Flutter 渲染解决的问题，基本上看是能够满足我们在性能和体验上的诉求的：字体不一致问题 ：通过自定义 Flutter Engine 实现跟随系统原生视图字体；视频、地图等同层渲染 ：Flutter 官方提供了一种机制，通过 Texture Widgets 的方式将 Native 平台渲染的 Texture 同步到 Flutter 的渲染体系中来，保证同一时刻界面上仅存在一种视图体系；文本输入框性能提升 ：相比 WebView 在低端机上有可见的性能指标提升；减少重复资源投入， 多平台维护 ：基本上只需要维护 Dart 和 C++ 代码，平台相关代码可以最小化。当然， 目前阶段在性能上还存在很大的进步空间 ，相比 RN-like 方案的各项性能指标并未达到最佳，仍需要充分的发挥 Flutter 的特性，提高这套框架整体的可用性。注： 由于开发阶段方案变化较快，此处对比数据并未在同样的设备下测定，仅以相对 WebView 渲染提升为例做为说明。五、总结与展望回顾一下上下文，微信在客户端跨平台开发方案的探索从最早期的打造高质量、开源化的基础组件，到现在尝试探索大前端技术栈的业务跨平台开发方案，始终是 从提升研发团队效能和最终产品用户体验两个角度出发，去思考如何能够不断地提高移动研发技术水平 。 如果把我们的视线重新拉回来这一根本出发点，今天我们所分享的渲染方案也并不一定是小程序技术栈作为跨平台开发的唯一优化方案选择 。WebView 渲染真的无法有突破性提升？跨平台开发只有大前端技术选择？随着大前端技术不断的发展和深入，相信未来一定会继续出现新的技术方案去解决现有研发流程中的问题，也欢迎大家继续关注我们的最新进展。Q & A在 GMTC 2019 大会分享结束后，我们陆续收到了很多同学提出的疑问，这里也统一整理了一些具有代表性的问题统一回答。Q1. 小程序在产品上是否会有什么改变？是否会放弃 WebView 渲染转向 Flutter 渲染？A1. 微信小程序是一个独立的生态和产品，使用 WebView 渲染具有极大的灵活性和前端兼容性，不会放弃 WebView 渲染。目前我们的尝试仅限于微信客户端内部部分场景使用，对微信小程序的外部开发者不会有任何影响。Q2. 使用 Flutter 渲染的这套方案在遇到复杂 CSS 属性的时候表现如何？A2. 过于复杂的 CSS 属性，我们不会支持。当前在 LV-CPP 上支持的 CSS 是一个比较小的子集（我们内部称之为 “WXSS-LITE”），从性能和复杂度角度去看，也不会支持完整 CSS 属性。针对内部开发的业务来说，会根据性能、支持的复杂度和必要性等方面综合决定是否纳入 WXSS-LITE 支持范围，即也有可能大幅限制内部开发同学能够使用的 CSS 属性。Q3. js2dart 模块是否支持传递对象和自定义数据，是否考虑开源或者开放出来供大家使用？A3. JS 和 Dart 都有各自的执行机制和对象模型，所以是无法直接的传递对象的，事实上也不需要，但是可以借助于引用或者其他的数据结构来解决对象映射的问题，以及自定义的数据结构也可以在一定的协议之上来完成，甚至可以基于共享内存的方案来传递大块的数据都没有问题。 开放使用方面，我们也在考虑，但具体的方式还在讨论中，希望我们的解决方案能够为广大的开发者带来更广阔的想象空间。Q4. iOS 端接入会带来包大小的变化，以及无法 Hot Patch，你们对 iOS 的接入是怎么做的？A4. 我们最初是从 Android 平台去切入的，iOS 的接入会晚一点，根据我们实际的调研情况来看呢，iOS 的同学对开发工具、包大小、动态性等都比较关注，后续我们也准备在这些方面去做一些研究，和 iOS 的同学一起来探讨出一些解决方案，也希望大家积极的拥抱新技术，在社区当中分享自己的解决方案。但无论怎么讲，我们使用新技术的目的是为了解决我们遇到的问题，只要是对我们有益的技术，我们一定会持续的跟进。"}
{"title": "如何两步完成一个抽奖小程序 ", "author": "Rolan", "pubtime": "2019-7-4 00:49", "content": "前言\r\n这是一个简单的抽奖+闹钟小程序，起源于本人不想去上课又觉得心里有愧(大学生懂得都懂)，干脆做一个抽奖系统，让系统帮我决定是否去上课\r\n\r\n作者是一名在校大学生兼前端小白，刚开始学习前端，这个小程序算是一个巩固练手项目吧，若文章中有错误的地方欢迎指正\r\n\r\n描述\r\n我的想法是把页面分为首页和闹钟页，首页实现点击按钮随机抽取一个选项 根据所选中的选项弹出相应的提示框，若选中的选项为时间，则跳转到闹钟页，闹钟页开始倒计时，时间到了之后播放闹铃并弹出提示框，下面让我们开始吧\r\n第一步\r\n页面\r\n页面方面比较简单，首页就是把九张图片以九宫格的形式放置，这里直接贴上代码\r\nindex.html\r\n<view class=\"container\">\r\n  <view class='frame_view'>\r\n    <view class='frame_row'>\r\n      <image class='frame_item' style='opacity:{{color[0]}}' src='{{images[0]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[1]}}' src='{{images[1]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[2]}}' src='{{images[2]}}'></image>\r\n    </view>\r\n    <view class='frame_row'>\r\n      <image class='frame_item' style='opacity:{{color[7]}}' src='{{images[7]}}'></image>\r\n      <image class='frame_item' src='{{btnconfirm}}' bindtap='{{clickLuck}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[3]}}' src='{{images[3]}}'></image>\r\n    </view>\r\n    <view class='frame_row'>\r\n      <image class='frame_item' style='opacity:{{color[6]}}' src='{{images[6]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[5]}}' src='{{images[5]}}'></image>\r\n      <image class='frame_item' style='opacity:{{color[4]}}' src='{{images[4]}}'></image>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码这时我们的页面应该是这样的\r\n\r\n\r\n闪电代表的是立即去上课， 微笑代表的是不去上课，Iconfont里找的图属实有点抽象 \r\n\r\n\r\n值得注意的是这里把图片的透明度和地址都放在了一个数组里，方便后面实现轮播的功能，初始数据为\r\n\r\ndata: {\r\n    color: [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5],\r\n    images: ['/images/likequ.png', '/images/fiveminutes.png', '/images/thirtyminutes.png', '/images/likequ.png', '/images/onehour.png', '/images/fiveminutes.png', '/images/likequ.png', '/images/buqu.png'],\r\n    btnconfirm: '/images/dianjichoujiang.png',\r\n    clickLuck: 'clickLuck',\r\n    luckPosition: 0\r\n  },\r\n复制代码第二步\r\n开始抽奖\r\n\r\n在此之前先在app.js中定义全局变量\r\n\r\nglobalData: {\r\n  number: 0,\r\n  numbers: 0,\r\n  remainTime: 0\r\n}\r\n复制代码点击开始抽奖之后设置按钮为不可点击，并生成一个1-7的随机数，根据生成的随机数改变图片的透明度实现抽中效果，之后把全局变量传给闹钟页面\r\nindex.js\r\nclickLuck() {\r\n    let self = this\r\n    self.setData({\r\n      btnconfirm: '/images/bunengdianji.png',\r\n      clickLuck: '',\r\n      luckPosition: parseInt(Math.random()*8)\r\n    })\r\n\r\n    clearInterval(interval)\r\n    let index = 0\r\n    interval = setInterval(() => {\r\n      if (index > 7) {\r\n        index = 0\r\n        self.data.color[7] = 0.5\r\n      } else if (index !=0) {\r\n        self.data.color[index-1] = 0.5\r\n      }\r\n      self.data.color[index] = 1\r\n      self.setData({\r\n        color: self.data.color\r\n      })\r\n      index++\r\n    },intime)\r\n    setTimeout(() => {\r\n      self.stop(self.data.luckPosition)\r\n    },2000)\r\n  },\r\n  stop(which) {\r\n    let self = this\r\n    clearInterval(interval)\r\n    let current = -1\r\n    let color = self.data.color\r\n    for(let i=0;i<color.length;i++) {\r\n      if(color[i] == 1) {\r\n        current = i\r\n      }\r\n    }\r\n    let index = current + 1\r\n    self.stopLuck(which, index, intime, 10)\r\n  },\r\n  stopLuck(which, index, time, splittime) {\r\n    let self = this\r\n    let color = self.data.color\r\n    setTimeout(() => {\r\n      if(index > 7) {\r\n        index = 0\r\n        color[7] = 0.5\r\n      } else if (index != 0) {\r\n        color[index - 1] = 0.5\r\n      }\r\n      color[index] = 1\r\n      self.setData({\r\n        color\r\n      })\r\n      if (time < 400 || index != which) {\r\n        splittime++\r\n        time +=splittime\r\n        index++\r\n        self.stopLuck(which, index, time, splittime)\r\n      } else {\r\n        setTimeout(() => {\r\n          if (which == 0 || which == 3 || which == 6) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '别偷懒，立刻去上课',\r\n              showCancel: false,\r\n              success(res) {\r\n                self.setData({\r\n                  btnconfirm: '/images/dianjichoujiang.png',\r\n                  clickLuck: 'clickLuck'\r\n                })\r\n                self.loadAnimation()\r\n              }\r\n            })\r\n          } else if (which == 1 || which == 5) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '五分钟后再去上课，点击确定开始计时',\r\n              showCancel: false,\r\n              success(res) {\r\n                wx.switchTab({\r\n                  url:\"/pages/clock/clock\",\r\n                  success: function(res) {\r\n                    getApp().globalData.number = 1;\r\n                    getApp().globalData.numbers = 1;\r\n                    getApp().globalData.remainTime = 300000;\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } else if (which == 2) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '三十分钟后再去上课，点击确定开始计时',\r\n              showCancel: false,\r\n              success(res) {\r\n                wx.switchTab({\r\n                  url:\"/pages/clock/clock\",\r\n                  success: function(res) {\r\n                    getApp().globalData.number = 2;\r\n                    getApp().globalData.numbers = 2;\r\n                    getApp().globalData.remainTime = 1800000;\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } else if (which == 4) {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '一小时后再去上课，点击确定开始计时',\r\n              showCancel: false,\r\n              success(res) {\r\n                wx.switchTab({\r\n                  url:\"/pages/clock/clock\",\r\n                  success: function(res) {\r\n                    getApp().globalData.number = 3;\r\n                    getApp().globalData.numbers = 3;\r\n                    getApp().globalData.remainTime = 3600000;\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } else {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: '今天有点累，就不去上课了吧',\r\n              showCancel: false,\r\n              success(res) {\r\n                self.setData({\r\n                  btnconfirm: '/images/dianjichoujiang.png',\r\n                  clickLuck: 'clickLuck',\r\n                })\r\n                self.loadAnimation()\r\n              }\r\n            })\r\n          }\r\n        },1000)\r\n      }\r\n    },time)\r\n  },\r\n复制代码现在一个简单的抽奖功能已经完成了，让我们看下效果\r\n\r\n轮播\r\n\r\n接下来让我们实现一下轮播的效果，就像小时候玩的老虎机一样，当没有人在玩的时候，它会自动转动\r\nloadAnimation() {\r\n    let self = this\r\n    let index = 0\r\n    interval = setInterval(() => {\r\n      if (index > 7) {\r\n        index = 0\r\n        self.data.color[7] = 0.5\r\n      } else if (index !=0) {\r\n        self.data.color[index-1] = 0.5\r\n      }\r\n      self.data.color[index] = 1\r\n      self.setData({\r\n        color: self.data.color\r\n      })\r\n      index++\r\n    },100)\r\n  }\r\n复制代码把它放入onLoad生命周期中，这样抽奖页面就完成了\r\n闹钟页面\r\nclock.html\r\n<view class=\"container\">\r\n\t\t<view class=\"clock\">\r\n\t\t\t<view>{{listData[0].countDown}}</view>\r\n\t\t</view>\r\n\t\t<view wx:if=\"{{number == 0}}\">\r\n\t\t\t<botton class=\"btn\" loading=\"{{loading}}\" disabled=\"{{disabled}}\" bindtap=\"primary\">点击抽奖</botton>\r\n\t\t</view>\r\n\t\t<view wx:if=\"{{number != 0}}\">\r\n\t\t\t<botton class=\"btn\" loading=\"{{loading}}\" disabled=\"{{disabled}}\" bindtap=\"primary_fq\">放弃计时</botton>\r\n\t\t</view>\r\n</view>\r\n复制代码初始数据为\r\ndata: {\r\n    number: 0,\r\n    numbers: 0,\r\n    listData: [\r\n      {\r\n        id: 0,\r\n        remainTime: 0\r\n      }\r\n    ]\r\n  },\r\n复制代码倒计时\r\n这里的思路是根据首页传回来的数据用定时器对数组进行减少处理\r\nsetCountDown () {\r\n    let time = 1000;\r\n    let { listData } = this.data;\r\n    let list = listData.map((e) =>{\r\n      if (e.remainTime <= 0) {\r\n          e.remainTime = 0;\r\n      }\r\n      let formatTime = this.getFormat(e.remainTime);\r\n      e.remainTime -= time;\r\n      e.countDown = `${formatTime.mm}:${formatTime.ss}`;\r\n      if (e.remainTime == 0) {\r\n        wx.playBackgroundAudio({\r\n          dataUrl: '/images/naozhong.mp3',\r\n          title: '闹钟',\r\n          coverImgUrl: ''\r\n        })\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '时间到啦!',\r\n          showCancel: false,\r\n          success(res) {\r\n            wx.pauseBackgroundAudio()\r\n          }\r\n        })\r\n      }\r\n      return e;\r\n    })\r\n    this.setData({\r\n        listData: list\r\n    });\r\n    setTimeout(this.setCountDown, time);\r\n  },\r\n复制代码\r\ngetFormat()是一个格式化时间的函数\r\n\r\ngetFormat (msec) {\r\n    let ss = parseInt(msec / 1000);\r\n    let ms = parseInt(msec % 1000);\r\n    let mm = 0;\r\n    let hh = 0;\r\n    if (ss > 60) {\r\n      mm = parseInt(ss / 60);\r\n      ss = parseInt(ss % 60);\r\n      if (mm > 60) {\r\n        hh = parseInt(mm / 60);\r\n        mm = parseInt(mm % 60);\r\n      }\r\n    }\r\n    ss = ss > 9 ? ss : `0${ss}`;\r\n    mm = mm > 9 ? mm : `0${mm}`;\r\n    hh = hh > 9 ? hh : `0${hh}`;\r\n    return { ms, ss, mm, hh };\r\n  }\r\n})\r\n复制代码完整效果图\r\n\r\n当时间到了的时候\r\n\r\n总结\r\n这只是我临时兴起的一个小项目，如果你觉得还不错，不妨给个赞鼓励下，您的鼓励是我前进的动力。\r\n最后奉上源码。"}
{"title": "我的第一个小程序：小程序与SEO ", "author": "Rolan", "pubtime": "2019-7-5 00:02", "content": "在之前的文章里，我曾提到小程序是C/S程序，而SEO的基本要求是B/S程序，需要网页做SSR(服务端渲染)，这样才能让爬虫通过简单的HTTP请求获得网页内容，然后根据内容生成索引，最终通过搜索引擎向用户呈现搜索结果，那么在小程序里如何做SEO呢？今天我们就来聊一聊微信小程序里的SEO。从技术角度看，SEO本质上是让用户在搜索引擎中输入关键词直接触达网站更多的次级页面，通常这些次级页面被称为Search Landing Page(简称SLP)。我们先来看看小程序的页面在微信App中的逻辑结构图：从上图我们可以看到，整个微信App是一颗树:evergreen_tree:，而每个小程序是其中的一个树干，小程序中的内页就是这颗树的叶子，那么想要直接触达这片叶子的路径就是：微信 > 小程序 > MiniApp > page\r\n复制代码这点与我们在规划Web站点SEO时基本一样。有了路径接下来就是检查该路径下是否存在内容，此时就需要渲染该路径所对应的小程序页面。尽管小程序是C/S程序，即客户端渲染，但是它寄身在微信App内，所使用的渲染引擎和脚本解释引擎均由微信提供，所以实现对小程序内页的渲染与爬取对微信来说并不是问题。通过对小程序内页的爬取和渲染，再针对爬取结果建立搜索索引，最后通过微信搜索将这些内容呈现给用户，俨然一个微信搜索王国就诞生了。举个栗子，通过下面的链接就可直接触达我小程序的内页：// 小程序链接如下： pages/detail/detail.html?id=5d0f58995d5cfb047c5676bc 到这里，已经基本讲完微信小程序搜索的实现。接下来我们看看微信里对搜索爬虫的相关规范：打开小程序的源代码，我们发现在代码的根目录下有这样的一个文件：// 文件：sitemap.json\r\n{\r\n  \"desc\": \"风清洋\",\r\n  \"rules\": [{\r\n  \"action\": \"allow\",\r\n  \"page\": \"*\"\r\n  }]\r\n}\r\n复制代码在这个文件里定义了微信搜索的爬虫协议，下面引用微信官方的文档来说明一下该文件的意义：微信现已开放小程序内搜索，开发者可以通过 sitemap.json 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。 爬虫访问小程序内页面时，会携带特定的 user-agent：mpcrawler 及场景值：1129。需要注意的是，若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。关于微信小程序的爬虫说明，官方文档只有这一篇，十分地简单，而做过SEO的同学可能会产生诸多疑问，比如：站点地图如何提交页面死链如何处理站内链接如何建设站外链接如何获得页面内容如何语义化是否存在索引沙盒如何防止作弊...诸般疑问，从目前微信官方提供的文档还没有看到更多说明，我猜测微信还没有想好怎么做，毕竟它不是做搜索起家，很多基础设施还不完善，只能多一些耐心等待微信去解决了。在一个新的市场刚刚建立的时候，有很多新机会诞生，以前熟悉网站SEO的人肯定明白我的意思。当然作为SEO小白，专心做好内容和服务也可以在这块新的市场中分到属于你的一片蛋糕。最后，小程序SEO的裁判只有微信自己，别人无法参与竞争，赏善罚恶只能期望微信的高风亮节。参考文档： developers.weixin.qq.com/miniprogram…"}
{"title": "微信小程序自动化测试实践总结 ", "author": "Rolan", "pubtime": "2019-7-5 00:42", "content": "本文作者：IMWeb IMWeb团队 原文出处：IMWeb社区 未经同意，禁止转载一、缘起-为什么要进行小程序自动化测试微信小程序生态日益完善，很多小程序项目页面越来越多，结构越来越复杂，业务逻辑也更加多样。以腾讯课堂小程序为例，目前腾讯课堂小程序部分页面结构和不同业务场景下的表现如下图所示：可以看到在核心功能上主要页面对于不同业务场景有众多不同的表现，因此在开发与发布的过程中需要手动验证大量测试用例以保证小程序按预期表现运行，善于利用工具的程序员当然会想：这种重复的工作能不能交给程序自动进行呢？web开发中对于这类测试问题已经有了很多自动化解决方案比如Selenium、Puppeteer，思路大体相同，都是让浏览器按照指定顺序自动在页面上完成点击、输入等操作，再将操作后的页面表现与想要得到的结果进行比较得到测试结论（断言）。那小程序中有没有一种方案能够按照这种思路实现自动化操作并提供页面信息用于断言呢？为了微信底层安全考虑，小程序环境一直比较封闭，留给开发者操作的余地很小，自动化操作基本无法实现，但5月底出现了miniprogram-automator工具，给了小程序开发者希望。二、缘遇-初试miniprogram-automator基于miniprogram-automator的文档描述简单总结一下，当通过命令打开开发版微信开发者工具的自动化接口并连接自动化接口后，此工具可提供以下能力：MiniProgram：获取小程序信息（页面堆栈、系统信息、页面内容），控制小程序（跳转页面、切换tab、调用方法）Page：获取页面信息（路径、元素、数据、结构），控制页面（设置渲染数据、调用方法）Element：获取元素信息（属性、样式、内容、位置），操控元素（点击、长按、调用方法）所以小程序自动化控制的实现依赖于开发版小程序开发者工具以及miniprogram-automator工具。小程序开发者工具命令行用来打开指定自动化操作服务端口。（开发者工具版本需高于v1.02.1906042）。miniprogram-automator工具用来操作开发者工具中运行的小程序并获取所需的信息。对于测试需求可以结合jest框架进行测试用例的组织和断言。不多废话，看完文档用一下：Ø 调用开发者工具命令行打开项目与指定自动化操作服务端口PS D:\\programs\\内测\\微信web开发者工具> ./cli.bat --auto D:\\weApp\\testMiniprogram --auto-port 9420\r\nInitializing...\r\nidePortFile: C:\\Users\\billcui\\AppData\\Local\\微信开发者工具\\User Data\\Default\\.ide\r\nstarting ide...\r\nIDE server has started, listening on http://127.0.0.1:35510\r\ninitialization finished\r\nOpen project with automation enabled success D:\\keminiapp\\weapp-ke\r\n这一行命令需要注意的有：文档要求开发者工具版本号必须高于v1.02.1906042，最好是最新的内测版工具，我是在v1.03.1906062运行成功的；运行这行命令之前需要先打开开发者工具菜单中的设置->安全设置->服务端口；自动化端口是独立于服务端口的(比如终端打印出的35510其实是服务端口)，必须要看到Open project with automation enabled success D:\\keminiapp\\weapp-ke这行提示才算是成功打开了自动化端口(9420)。命令运行成功后，开发者工具会自动打开项目，并弹出提示Ø npm i miniprogram-automator --save-dev安装SDK，创建test.js，代码中引入miniprogram-automator工具，连接自动化操作端口const automator = require('miniprogram-automator');\r\n\r\nconst miniProgram = automator.connect({\r\n  wsEndpoint: 'ws://localhost:9420',\r\n})\r\nØ 利用miniprogram-automator提供的接口操作小程序从首页重启并进行相关操作const automator = require('miniprogram-automator');\r\n\r\nconst miniProgram = automator.connect({\r\n  wsEndpoint: 'ws://localhost:9420',\r\n}).then(async miniProgram => {\r\n  // 从首页重启\r\n  const page = await miniProgram.reLaunch('/pages/index/index');\r\n  // 从页面获取bottom-button组件\r\n  const button = await page.$('bottom-button');\r\n  // 打印出button的wxml信息\r\n  console.log(await button.wxml());\r\n}).catch(e => {\r\n  console.log('catch a error', e);\r\n});\r\nØ 利用miniprogram-automator获取操作后页面相关信息，利用jest进行组织和断言// index.spec.js\r\nconst automator = require('miniprogram-automator');\r\n\r\ndescribe('课堂小程序自动化测试', () => {\r\n  let miniProgram;\r\n  // 运行测试前调用\r\n  beforeAll(async () => {\r\n    miniProgram = await automator.connect({\r\n      wsEndpoint: 'ws://localhost:9420',\r\n    });\r\n  });\r\n  // 运行测试后调用\r\n  afterAll(() => {\r\n    miniProgram.disconnect();\r\n  });\r\n  // 测试内容\r\n  it('nohost检测', async () => {\r\n    const page = await miniProgram.reLaunch('/pages/index/index');\r\n    const nohostButton = await page.$('nohost');\r\n    expect(nohostButton).toBeNull();\r\n  });\r\n});\r\n运行jest index.spec.js， 如果页面中不存在nohost组件则测试通过，结果如图所示：三、缘聚-自动化测试在课堂微信小程序中的应用腾讯课堂微信小程序引入自动化测试主要是为了解决开发、预发布环境、正式环境需要反复多次打开用例课程页面，操作繁琐，耗费大量人力的问题。针对课堂小程序checklist，尽可能利用自动化测试程序完成测试验证，减少手动操作，也可以避免人为检测的遗漏。利用miniprogram-automator工具和jest框架，自动化测试主要能力为按照指定顺序模拟打开指定页面、点击、滚动等操作和设置page的data渲染数据，然后对特定的页面结构、数据、组件属性等信息进行断言，判断是否符合预期。下面以腾讯课堂微信小程序的课程详情页为例来详细说明在实际项目中如何实现自动化测试：课程详情页的UI主要分为视频部分，详情部分以及底部的购买按钮，未购买课程时付费课程详情页表现如下：假如对于未购买的无优惠活动的付费课程详情页的测试目标如下：按钮应显示“立即购买”，点击购买按钮可跳转到支付页点击试学按钮可正常播放试学视频未购买课程时点击课程视频无法播放实现这个测试，在x.spec.js文件中首先需要要按照上文的步骤引入miniprogram-automator，在beforeAll中连接已经打开自动化端口的微信小程序项目。（这里不再重复代码，见上一章）下面直接看测试内容的代码。按钮显示和点击跳转支付页测试   // 打开页面，通过url传参\r\n   const page = await miniProgram.reLaunch(`/pages/course/course?cid=${commonPayCid}`);\r\n   // 获取按钮组件信息\r\n   const basicApplyButton = await page.$('.basic--buy');\r\n   // 判断按钮显示内容\r\n   expect(await basicApplyButton.wxml()).toContain('立即购买'); \r\n   // 模拟点击按钮\r\n   await basicApplyButton.tap();\r\n   // 等待页面跳转\r\n   await page.waitFor(1500);\r\n   // 获取当前页面路径\r\n   const currentPage = await miniProgram.currentPage();\r\n   // 判断跳转后路径是否正确\r\n   expect(currentPage.path).toContain('pages/order/order');\r\n   // 跳转回来\r\n   await miniProgram.navigateBack();\r\n目前miniprogram-automator提供了两种方法获取到页面中的组件：page.$和page.$经过实验发现两者的selector支持通过组件名和类名选择组件，但对于自定义组件内部的结构，就不能直接这样拿到了。课程详情页的底部按钮其实是一个自定义组件，并且还嵌套了子自定义组件，我们看一下底部按钮的wxml结构:红色框框就是想要获取的目标，尝试一下直接通过page.$('.bottom-btn')或page.$('.buy')返回的都是undefined，那怎么获取呢？我们先来看看botton-button内部是什么样子的。const basicApplyButton = await page.$('bottom-button');\r\nconsole.log(await basicApplyButton.wxml());\r\n获取bottom-button并打印它的wxml字符串看一下：// 输出实际上是字符串，为了方便显示格式化了一下\r\n<view class=\"bottom-button--bottom-button-space\" wx:nodeid=\"17\">\r\n    <view class=\"bottom-button--bottom-button-wrapper\" wx:nodeid=\"261\">\r\n        <basic is=\"components/discount-button/components/basic/basic\" wx:nodeid=\"262\">\r\n            <view wx:nodeid=\"263\">\r\n                <view class=\"basic--bottom-button-container\" wx:nodeid=\"264\">\r\n                    <view class=\"basic--bottom-btn basic--buy\" wx:nodeid=\"265\">立即购买</view>\r\n                </view>\r\n            </view>\r\n        </basic>\r\n    </view>\r\n</view>\r\n发现了什么！小程序实际运行时，自定义组件内部的类名都加上了组件名前缀，再试试page.$('.basic--buy')发现果然成功获取到了，所以虽然表面上miniprogram-automator只能操作和获取page中的内容，但自定义组件内部的结构实际上也是以某种方式存在于page中的。接下来看一下跳转，可以直接获取到对应组件后调用.tap()方法来模拟点击，这里需要注意的是，由于微信小程序开发者工具中点击打开新页面耗时较长，需要等待页面加载一会，不然接下来获取当前页面路径的时候页面还没跳转过去就拿不到不到新页面路径了。等待的时长可以根据经验给个稍大的比较安全的值。点击试学按钮可正常播放试学视频const player_video = await tapTcplayer(page, '.player-task');\r\nexpect(await player_video.wxml()).toContain('video-current-time'); // 试学\r\n由于微信开发者工具的限制，云点播会降级为tcplayer播放，tcplayer内部的核心组件其实是<video>组件，wxml结构如下：如何判断视频是否成功播放呢？我们先按照上面的方法获取播放成功的video组件的wxml字符串看看   \"<video class=\"component-video-video--player_video\" controls=\"\" danmu-list=\"[]\" initial-time=\"0\" object-fit=\"contain\" poster=\"https://10.url.cn/qqc...\" src=\"http://113.96.98.148/vedu.tc.qq.com/AtmkzyWCuq...\" autoplay=\"\" wx:nodeid=\"446\"><div class=\"video-container\" wx:nodeid=\"447\"><div class=\"video-bar full\" style=\"opacity: 1;\" wx:nodeid=\"457\"><div class=\"video-controls\" wx:nodeid=\"458\"><div class=\"video-control-button pause\" wx:nodeid=\"459\"><div parse-text-content=\"\" class=\"video-current-time\" wx:nodeid=\"460\">00:02<div class=\"video-progress-container\" wx:nodeid=\"462\"><div class=\"video-progress\" wx:nodeid=\"463\"><div style=\"left: -21px;\" class=\"video-ball\" wx:nodeid=\"464\"><div class=\"video-inner\" wx:nodeid=\"465\"><div parse-text-content=\"\" class=\"video-duration\" wx:nodeid=\"466\">06:09<div class=\"video-fullscreen\" wx:nodeid=\"468\"><div style=\"z-index: -9999\" class=\"video-danmu\" wx:nodeid=\"453\"></video>\"\r\n惊了！原生<video>组件内部竟然是<div> ，我们还可以注意到一个关键的class: video-current-time 内部数值为00:02，这不是当前播放进度吗？刚好可以用来判断视频有没有播放成功，就是它了！对比发现播放失败时根本不会出现class为video-current-time的div，所以直接用是否包含video-current-time来判断了。未购买课程时点击课程视频无法播放点击非试看课程时，无法播放视频。由于不播放视频时页面中只显示cover封面图，不attatch<video>组件，所以直接用获取视频组件的结果进行toBeNull()判断即可。结合上面所有的代码如下：async function tapTcplayer(page, className = '.task-item') {\r\n     const taskItem = await page.$(className);\r\n     await taskItem.tap();\r\n     await page.waitFor(3000);\r\n     const playercover = await page.$('.player-cover');\r\n     const player_video = await playercover.$('.component-video-video--player_video');\r\n     return player_video;\r\n   }\r\n   it('付费课程详情页按钮显示、跳转、点播、试学功能测试', async () => {\r\n       const page = await miniProgram.reLaunch(`/pages/course/course?cid=${commonPayCid}`);\r\n       const basicApplyButton = await page.$('.basic--buy');\r\n       expect(await basicApplyButton.wxml()).toContain('立即购买'); // 按钮显示\r\n       await basicApplyButton.tap();\r\n       await page.waitFor(1500);\r\n       const currentPage = await miniProgram.currentPage();\r\n       expect(currentPage.path).toContain('pages/order/order');\r\n       await miniProgram.navigateBack();\r\n       const player_video = await tapTcplayer(page);\r\n       expect(player_video).toBeNull(); // 未报名不能播放视频\r\n       const player_video_new = await tapTcplayer(page, '.player-task');\r\n       expect(await player_video_new.wxml()).toContain('current'); // 试学\r\n     }, 20000);\r\n可以看到实际上先测试了播放课程功能，再测试了试学功能，这是为什么呢？这是一个坑：由于播放课程失败时会有showModel弹窗提示，这个弹窗是不在wxml结构中的，无法用自动化控制工具点击关闭，实际测试中这个弹窗会阻塞下一个测试项的第一步：页面跳转，导致下一个测试项直接打不开页面导致失败，只能等待一段时间再跳转，所以直接把弹窗放在测试试学功能之前，就不会影响下一个测试项了。还有一个需要注意的地方，在项目中，点击播放后5秒不触发进度刷新的方法就会上报视频播放失败，实际测试发现一般3秒即可正常播放，所以只等待3秒，3秒后未成功播放的视为播放失败。最后，jest默认一个测试项的时长不能大于5秒，这项测试既有页面跳转又有视频播放，明显会超出5秒的限制，实际耗时约为15秒左右，所以修改时长限制为20000毫秒。运行测试脚本结果如下：目前实现的测试功能如下：nohost检测首页数据拉取、显示、跳转测试付费课程详情页按钮显示、跳转、点播、试学功能测试优惠券按钮显示、领取功能测试限时优惠按钮显示测试免费课程详情页按钮显示、报名、点播功能测试分类页展示、跳转列表页、跳转详情页测试Checklist中功能测试的完成情况如下：完成度为65%review点自动化测试备注是否去除nohost插件支持首页是否正常显示支持pc首页小程序登陆是否正常暂不信息授权无法自动完成安卓支付能力是否正常暂不webview内部无法获取信息分类页是否正常显示支持是否可以正常登陆暂不信息授权无法自动完成课程表是否正常展示，学习进度/直播状态是否正常显示支持待完善课程详情页是否可以正常展示支持扫码/分享是否正常唤起小程序暂不开发者工具不支持付费课直播是否可以正常播放（上云跟腾讯视频）暂不开发者工具不支持直播免费课直播是否可以正常播放（上云跟腾讯视频）暂不开发者工具不支持直播免费课录播是否可以正常播放（上云跟腾讯视频）部分支持开发者工具降级到tcplayer付费课录播是否可以正常播放（上云跟腾讯视频）部分支持开发者工具降级到tcplayer试学任务是否可以正常播放支持详情页视频是否正常播放支持营销工具相关显示是否正常支持是否能正常完成支付逻辑暂不webview内部无法获取信息类目筛选是否正常支持待完善是否可以正常搜索且列表显示正常支持待完善本地加载耗时是否保持1s内支持四、缘续-遇到的问题与功能限制获取页面中的组件只能采用page.$()或page.$$()方法，经尝试选择器仅支持组件名和类名。无法直接获取自定义组件内部组件元素，需要在类名前增加前缀。实际项目的页面中大量使用自定义组件，对于自定义组件内部的结构判断非常不方便，只能通过wxml()方法将自定义组件内部结构打印出来才能确认内部的子组件的实际情况。且无法调用自定义组件内部的方法。Jest的snapshot功能对于结构相对固定的组件或页面是一种非常好的测试方式，但用起来有坑。在小程序中snapshot的对照内容通常是通过组件的wxml方法打印的字符串，但实际在运行时，wxml方法返回结果可能会不同，组件可能会被自动添加上wx:node-id属性，但有时返回字符串中又不添加，会导致snapshot测试不通过。目前只能在开发者工具环境下测试，导致直播功能无法测试且云点播会自动降级为腾讯视频点播，直播也无法测试。登陆、扫码等功能无法测试，因为自动化控制工具无法扫描和点击授权弹窗。<web-view>组件获取不到任何内部信息，也无法自动化控制。希望这些问题后续能够得到解决~~"}
{"title": "Taro撸一个简版的微信读书小程序 ", "author": "Rolan", "pubtime": "2019-7-5 00:51", "content": "简介：想接触一下Taro玩一下，没事就撸一个微信小程序，一直在用微信读书看书，so就模仿做个简版的微信小程序，虽然无法上线，自己在体验版玩一下数据来源：通过node爬去的在线的读书内容，或者txt下载node解析之后，通过连接云函数存储到微信的云存储下面就简单的介绍一下吧云存储数据库表user 用户表{\r\n    \"_id\":\"3b07eb945d0c9f68054ec00b042158e7\",\r\n    \"uid\":\"e43fb05a2e1fc9741ac84f560cb73bbe\", // 用户的唯一标识（可无）\r\n    \"country\":\"China\",\r\n    \"nickName\":\"姓名\",\r\n    \"status\":0.0,\r\n    \"createTime\":\"2019-06-21 05:12:07\",\r\n    \"gender\":1.0,\r\n    \"openId\":\"oI_Av5bNR627zRPDlKbITtVlaXts\", // 用户的唯一openId\r\n    \"city\":\"Haidian\",\r\n    \"province\":\"Beijing\",\r\n    \"type\":0.0, // 用户类型（备用）\r\n    \"avatarUrl\":\"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIqcBA0Hhm5pTPLnXVTKiark5XLxiaJ7WyyIrUxcG60WfROZmJ2dt7VkUbmMzaOdXcPmAnicoM25vkYA/132\",\r\n    \"language\":\"zh_CN\"\r\n}\r\n复制代码book 书列表{\r\n    _id: \"\", // 书本的唯一标识\r\n    author: '刘慈欣', // 作者\r\n    name: \"三体\", // 书本名称\r\n    cover: \"https://rep.codequn.com/novel/cover/santi2.jpg\", // 封面图\r\n    chapter: \"\",\r\n    introduction:\"《三体》（别名“地球往事”三部曲）是刘慈欣所著长篇科幻小说，讲述了地球人类文明和三体文明的信息交流、生死搏杀以及两个文明在宇宙中的兴衰历程。2015年8月，《三体小说》荣获第73届雨果奖最佳长篇小说奖 。三体小说故事发生之时，文化大革命正在如火如荼地进行，军方探寻外星文明的绝秘计划“红岸工程”取得了突破性进展，在按下发射键的那一刻，历经劫难的叶文洁没有意识到，她彻底改变了人类的命运。\",\r\n    status: 0 // 书本的状态   1：书城可查看\r\n}\r\n复制代码user_book 用户书架{\r\n    _id: \"\",\r\n    book_id: \"\", // 书的_id\r\n    openId: \"\" // 用户openId\r\n}\r\n复制代码book_catalog 书章节{\r\n    _id: \"\", // 章节_id\r\n    book_id: \"\", // 书本_id\r\n    index: 1, // 章节的位置\r\n    title: \"\",// 章节名称\r\n    type: 0 // 判断是章节还是（卷或者部）\r\n}\r\n复制代码book_catalog_info 书章节详情{\r\n    _id: \"\", // 章节详情_id\r\n    book_catalog_id: \"\", // 书本章节_id\r\n    content: \"\", // 章节的内容\r\n    title: \"\",// 章节名称\r\n}\r\n复制代码遇到的问题\r\n\r\n\r\nnode服务上传到云存储数据经常出现bug，或者上传失败的问题，内容字节比较多，很容易出现失败，最后只能分成多次上传更新数据。（备注：先获取token，然后再去链接云函数）\r\n云开发 Server API 文档\r\n\r\n\r\n云函数获取的章节列表需要多次获取，每次最多获取100条数据\r\n\r\n\r\n小程序功能有点少，后面再继续更新吧\r\n技术使用\r\nTaro\r\nColorUi组件库\r\n现在正在撸一个简单的记事本小程序"}
{"title": "小程序与小游戏获取用户信息接口调整，请开发者注意升级。 ... ", "author": "Rolan", "pubtime": "2019-7-5 10:23", "content": "最近在开发小程序的过程中，获取用户信息一直得不到预期的效果，查了一些文档最终发现wx.getUserInfo接口不能弹出授权询问框了。https://developers.weixin.qq....微信相关公告如下为优化用户体验，使用 wx.getUserInfo 接口直接弹出授权框的开发方式将逐步不再支持。从2018年4月30日开始，小程序与小游戏的体验版、开发版调用 wx.getUserInfo 接口，将无法弹出授权询问框，默认调用失败。正式版暂不受影响。开发者可使用以下方式获取或展示用户信息：一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq...."}
{"title": "移动端小程序框架面面观 ", "author": "Rolan", "pubtime": "2019-7-9 00:24", "content": "一 小程序兴起的背景小程序兴起的背景可以分为行业背景和技术背景。1. 行业背景：与移动互联网成熟、流量红利终结伴随的是 App 的巨型化、寡头化，流量成本越来越高昂，这几点其实大家平时也有体会——手机里装了多少 App，其中，多少 App 装了之后基本没使用过，占据用户大部分时间的 App 越来越集中在 3—5 款。这种趋势普通用户都能深刻的感觉到，巨头们的感觉应该更明显。各种独立 App 纷纷小程序化，表面上只是技术实现方式的变化，从深层次讲，其实是在流量越来越贵，流量资源进一步集中下的精细化分发、运营和变现。以前流量从自家过，用稀疏的大网捞一捞就能有不错的收获，现在需要上绝户网挖掘各类垂直需求和长尾需求、尽量将用户更长时间地留在自己的领地。因此，小程序就是在这种行业背景下诞生的。2. 技术背景：从技术层面来看，动态化和跨平台两大特性能显著降低开发成本，提高运营的灵活性，因而在某种程度上成为开发者（公司）天然的追求。对此业界也进行了各种尝试，从早期的轻应用到后来的各种 Hybrid 框架、RN、Weex 等跨平台框架，以及各大公司内部的各种 DIY 私有框架，乃至于 PWA，算得上百花齐放，蔚为壮观。然而，业界始终没有在性能体验、稳定性、开发人群规模、开发难度、管控安全等方面找到一个兼顾各方平衡的方案和标准，至少从国内来看，没有一种方案占据绝对优势。既然无法达成一致，那只能做减法，在一定程度上舍弃对一致性的追求，小程序就是这一减法的产物。那么具体怎么减呢？减法 1：减小范围。既然在大范围内达不成一致，那就把范围限制在有限的自留地里；减法 2：限定场景。鉴于通用标准群众基础好，人群基数大，但历史包袱重、贪大求全的情况，可以选择参考其形式，但是只取一个子集，清晰限定自己场景问题的边界，以在利用开发者基数的同时降低开发门槛。小程序总体上就是沿着这种思路诞生的，其在缩小范围、舍弃了一部分通用性之后，在所关注的其他指标上取得了比较好的平衡，下文会具体讲到。二 小程序的技术方案选型关于小程序的技术方案选型，先把结论摆出来：总体上来讲，各家小程序框架的原理大同小异，具体到某个细节方面，根据各家资源禀赋还是各有不同的。这里的总体“类似”是来源于互相借鉴、英雄所见略同，还是历史进程的作用，就不得而知了。当然，对于 BAT 等巨头而言，只要了解了原理，要做出小程序并没有太大的障碍。具体来说，各家小程序框架的原理基本都是，顶层类 Web 语法 DSL（搭配各自的前端框架），底层主要依靠 WebView 渲染，在开发者层面大体上走的还是 Web 技术栈的路子。为了提高性能体验，开发者主要采取了下面几方面的措施：其一，把 JS 剥离，运行在另一个 WebView 或者 JSCore 上，在渲染层（WebView）之外，抽出逻辑层。视图层只负责渲染，逻辑层负责网络和本地数据的读取，并通过小程序框架搭建的通道跨线程将数据发送到渲染层完成界面的绘制，同时逻辑层也负责封装宿主侧的各类能力（宿主方的登陆、支付、AI 及各种传感器接口等）为特定的 API 接口供小程序开发者使用；其二，对于重型组件，直接采用 Native 嵌入渲染；其三，框架对 WebView 的创建和前端 JS 框架的加载都进行了缓存和预加载，并且拦截了小程序的关闭，多数情况下，关闭某个小程序只是将其隐藏在导航栈中，下次重新加载该小程序时能迅速唤起。下图展示了小程序冷启动和热启动的过程：为什么采用这套技术方案呢？上文谈到了小程序诞生的技术背景，从这些内容中可以进一步推导出小程序方案的技术诉求，总结起来，小程序方案的诉求主要有下面几点：1. 体验。性能、用户体验要好，这是首要的；2. 易用。接口要清晰简单，开发者基数要大，群众基础要好，这样才能降低开发门槛，门槛低了，成本自然就低了；3. 安全。平台上规则要能被平台方控制，以保证安全及平台方自身的利益。不同的诉求组合又对应着不同的解决方法：a) 考虑 1+2：抽取传统 WebView 中和排版渲染混在一起的 JS 逻辑，在渲染用的 WebView 之外，JS 逻辑运行在独立的 JSCore（or 另一个隐藏的 WebView 上），这样 JS 的执行不阻碍排版绘制。对于重型组件，直接采用 Native 嵌入渲染，这种做法能明显提高 WebView 的流畅性。同时这种技术方案能够最大程度继承 Web 开发的技术栈，使得开发技术简便（Web 标准可以理解为现阶段各大公司都能妥协、接受的跨平台标准，经过这些年的发展，Web 技术栈人员基数大、工具成熟，标准统一），开发成本低。b) 考虑 2+3：在上述类 Web 方案的基础上套上了一个自定义的前端框架（BAT 各家小程序上层的前端方案各不相同，不过大同小异，没有本质区别），进一步将暴露给开发者的语法精简，并且规范化下来。一方面平台上的开发者能够调用的都是平台方规定好的接口，保证了安全管控；另一方面，平台方可以在其各自的前端框架下，做一些语法糖或者特色功能，提高开发效率；同时，这个隔离层的引入为后续平台方对框架底层的优化，甚至完全更换渲染方式，如采用类似游戏引擎的直接绘制渲染提供了空间（PS：业界已经有团队进行了这方面的尝试。比如支付宝团队支持用 RN 来渲染小程序，微信团队尝试在小程序底层用 Flutter 来渲染，并进行了小范围的试验。底层渲染方式更改后，上层暴露给开发者的 DSL 保持不变，开发者是无感的。鉴于这些不是目前主流的实现方式，且本文目的在于读者对于小程序的技术选型有相对大视角的了解，故不详细展开）。c) 上述 a+b 中描述的方案，同时也能满足第 3 点的要求。这是因为：其一，JS 被分离出去，不能任意操纵原来的 Dom 结构，不能获取各种浏览器对象；其二，开发者所用的框架语法、能力接口（各种端侧能力，如文件、网络、传感器等）都必须是平台方定义好暴露出来的，平台方可以控制权限的获取以决定开发者是否可以调用该接口，有完全的控制能力。总体来讲，通过上述方式，小程序被关在了笼子里，保证了平台方的控制权和安全性。下图展示了小程序整体框架原理：小程序框架暴露给开发者的内容，大体分为两类：组件及接口。组件部分主要包含各类小程序框架提供的 UI 组件，接口部分主要是包含各类宿主端侧开放接口，如登陆、支付、网络、多媒体以及对应各家资源禀赋的一些特色化能力。各家小程序的 Demo 基本上也是按照这个分类来展示的：三 小程序在技术层面的长和短当然，任何一个技术方案在获取其目标收益的同时都有其代价。上述小程序方案的代价主要有以下几点：1. 技术栈迁移的成本从整体上看，尽管小程序一定程度上借鉴了通用的 Web 标准，但毕竟只是借鉴，完全迁移过来有一定的学习成本。目前各家的小程序方案在上层都是搭配自己的前端框架，尽管都参考了流行的前端框架，但毕竟是阉割版的，且思路各有差异。此外，各家暴露给开发者的宿主侧能力接口也有一定的区别。所以小程序在总体上面临着技术栈迁移的问题。2. 数据传输同步的开销渲染层和逻辑层各自运行在完全隔离的环境里，数据和事件的同步需要序列化为文本协议流，在传输大的数据对象时开销是比较可观的。各家的开发文档里也都特意提到不要在逻辑层和渲染层之间频繁传输大量数据，以免影响性能。3. 天生的异步延时性由于小程序的逻辑层和渲染层分别运行在两个独立的环境，所以逻辑层和渲染层之间的通信是异步的，会有一定的延时。除了逻辑层和渲染层之间的通信有延时，各层与宿主客户端之间的交互同样也是有延时的。以逻辑层为例，开发者的代码是运行在逻辑层的线程上，但是客户端原生是运行在宿主线程上的，逻辑层调用相关宿主客户端的接口，实际上也是两个线程间的通信，这就意味着延时。所以小程序框架大部分接口都是异步的，这些异步通信，框架处理了一部分，保证了框架主要部分的基本时序，但是更多地留给了开发者自己处理，这增加了使用的复杂性。4. 审核的不确定性小程序的本质上是巨型 App 的应用商店化。这动了原生系统平台方的奶酪，这里的原生系统平台方既包括 App store、Google play，也包括国内各手机厂商的应用商店及各种第三方渠道，目前正在推广的快应用某种程度上可以视为后者的一种反击。就国内而言，在不同平台、尤其是苹果平台上的审核问题，为小程序的发展带来了较多不确定性。四 集成形态上各家的不同做法关于小程序的集成形态，各家采用了不同的做法，套用军事领域的比方来说就是“航母巨舰 VS 战列舰 + 空潜快”，颇有点强国海军和后起新兴国家海军之间形成对垒的意味。微信和支付宝走的是“航母巨舰”的路子，小程序集成在其体量巨大的国民应用上；百度走的是“战列舰 + 空潜快”的路子，这里的一个关键点是开源，先在自家各大型 App 铺开（战列舰），然后通过开源吸引各中小 App（空潜快）集成，组成小程序的开源联盟。在移动时代，B 家最大的焦虑是各大移动应用对它来说是死硬的黑盒子，其完全无法插足（早期的淘宝屏蔽百度是最早的一种形态），而通过小程序，百度倒是有希望打开一个缺口，因为其完全了解小程序内部的元数据信息，可以做到精准的分发。以前分发网页，对应的有站长联盟，现在分发小程序，对应的有小程序联盟。不过要把开源联盟做起来，仅凭简单的代码框架开源是远远不够的，更重要的是看利益分配机制的设计及整个商业模型的规则，毕竟接入方的流量也是需要成本的。五 小程序的迁移性和标准化严格来讲，小程序技术目前并没有做到通常意义上的标准化，这体现在开发者层面，各家上层语法及暴露的宿主侧 API 都有一定的差异。不过由于各家小程序框架的整体技术方案选型类似，所以这种差别不会给学习造成太大的障碍。而且，对于增强开发者在各不同平台之间迁移的便利性的问题，业内已经出现了一些解决方案。一方面，多数小程序玩家的后来者都提供了搬家迁移工具，能自动处理大多数语法转换类问题；另一方面，也出现了一些小程序通用框架，如 Taro、Mpvue 等，它们提供了类现代前端框架（Vue/React）的语法去开发小程序，并同时支持多个小程序平台。所以，尽管小程序还没有做到完全的标准化，但是已经达到事实上准标准化的程度，开发者在学习并为其中一种平台开发小程序之后，可以很容易的将经验和已有成果迁移到其他小程序平台。六 总结小程序技术可以认为是现阶段巨型 App 容器化、平台化、MiniOS 化的背景下，在总结业界近年来在动态化跨平台框架领域的各种方案的基础上的另一种尝试。目前看来，小程序方案较好地平衡了性能体验、开发成本、平台管控等几方面的关切，满足了巨型 App 需要一种轻量级类 Web App 技术以进行垂直和长尾领域流量分发的要求，这也是国内各大巨头先后入局小程序的主要理由。本文转载自公众号爱奇艺技术产品团队（ID：iQIYI-TP）。原文链接：https://mp.weixin.qq.com/s/uh_miREB1w8FX7mWgph56w"}
{"title": "仿小米Lite微信小程序 ", "author": "Rolan", "pubtime": "2019-7-9 00:36", "content": "事先声明，这是一个高仿小米Lite的微信小程序。我呢现在是一个大三快大四的学生，这个小程序花了我很长时间，把能写的功能基本上都写了。我秉着分享开源的心理，尽量把我写的这个小程序怎么写的，为什么这样写，详细的告诉大家。为什么是尽量？这是因为，我不太会说，可能说的不是很清楚，所以只能尽量.项目预览ok实现的效果就是这样。使用的工具easy-mokeVSCode微信小程序开发者工具( 阿里巴巴矢量图标库 )文件目录├<assets>\r\n│  ├<images>\r\n├<components>\r\n│  ├<goodList>\r\n│  ├<icon>\r\n│  ├<tabbar>\r\n│  ├<userList>\r\n├<pages>\r\n│  ├<cart>\r\n│  ├<category>\r\n│  ├<deleteGoods>\r\n│  ├<find>\r\n│  ├<goodDetails>\r\n│  ├<index>\r\n│  ├<selectGoods>\r\n│  ├<user>\r\n├<utils>\r\n│  └util.js\r\n├<weui>\r\n│  └weui.wxss\r\n├<wxapi>\r\n│  ├Api.js\r\n│  ├main.js\r\n│  └mock.js\r\n\r\n复制代码对于初学者来说，可能拿到设计图就立马写，其实这样很不好，写出来的代码会有很多重复的代码，这样不利于之后的维护。所以应该把一些公用的代码封装，之后直接调用就行了，之后维护起来也更加的方便。API封装我们前端想要获取页面的数据，就需要发送HTTP请求后端提供给我们的API接口，从API接口中获取我们想要的数据。在微信小程序中，微信官方给我们提供了一个方法 wx.request 来请求.一个程序，需要的HTTP请求会很多，如果我们每个请求都去写一个wx.request，这样写出来的代码，看起来会很冗长，他人看我们的代码时也会很累，也不利于我们之后的修改。因此为了代码的整洁，和之后的修改方便。我就把所有的API请求请求封装在wxapi文件目录下。// Api.js\r\nconst banners = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/banners'\r\n\r\nconst navdata = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/navdata'\r\n\r\nconst goodList = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/goodList'\r\n\r\nconst category = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/category'\r\n\r\nconst findData = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/findData'\r\n\r\nconst userData = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/userData'\r\n\r\nconst goodDetail = 'https://www.easy-mock.com/mock/5cf9c392006feb28c7eedf28/goodDetail'\r\n\r\nconst QQ_MAP_KEY = 'NNFBZ-6DRCP-IRLDU-VEQ4F-TXLP2-PFBEN'\r\n\r\nconst MAPURL = 'https://apis.map.qq.com/ws/geocoder/v1/'\r\n\r\nmodule.exports = {\r\n  banners,\r\n  navdata,\r\n  goodList,\r\n  category,\r\n  findData,\r\n  userData,\r\n  goodDetail,\r\n  QQ_MAP_KEY,\r\n  MAPURL\r\n}\r\n复制代码import * as MOCK from \"./mock\"\r\nimport * as API from \"./Api\"\r\nconst request = (url,mock = true,data) => {\r\n  let _url = url\r\n  return new Promise((resolve, reject) => {\r\n    if (mock) {\r\n      let res = {\r\n        statusCode: 200,\r\n        data: MOCK[_url]\r\n      }\r\n      if (res && res.statusCode === 200 && res.data) {\r\n        resolve(res.data)\r\n      } else {\r\n        reject(res)\r\n      }\r\n    } else {\r\n      wx.request({\r\n        url: url,\r\n        data,\r\n        success(request) {\r\n          resolve(request.data)\r\n        },\r\n        fail(error) {\r\n          reject(error)\r\n        }\r\n      })\r\n    }\r\n  });\r\n}\r\n// showLoading\r\nconst showLoading = () => {\r\n  wx.showLoading({\r\n    title: '数据加载中',\r\n    mask: true,\r\n  });  \r\n}\r\n// 获取地理位置\r\nconst geocoder = (lat, lon) => {\r\n  return request(API.MAPURL,false,{\r\n    location: `${lat},${lon}`,\r\n    key: API.QQ_MAP_KEY,\r\n    get_poi: 0\r\n  })\r\n}\r\nmodule.exports = {\r\n  getBanners: () => {\r\n    // return request('banners')\r\n    return request(API.banners,false)  //首页 banners \r\n  },\r\n  getNavData: () => {\r\n    // return request('navdata')\r\n    return request(API.navdata,false) //首页 navdata \r\n  },\r\n  getGoodList: () => {\r\n    // return request('goodList')\r\n    return request(API.goodList,false)  //首页 商品列表\r\n  },\r\n  getCategroy: () => {\r\n    // return request('category')\r\n    return request(API.category,false)  //分类页面\r\n  },\r\n  getFindData: () => {\r\n    // return request('findData')\r\n    return request(API.findData,false)  //发现 页面\r\n  },\r\n  getUserData: () => {\r\n    // return request('userData')\r\n    return request(API.userData,false)  // 我的 页面\r\n  },\r\n  getGoodDetail: () => {\r\n    // return request('goodDetail')\r\n    return request(API.goodDetail,false)  //商品详情\r\n  },\r\n  showLoading,\r\n  geocoder\r\n}\r\n复制代码看到这里，可能就会有一些疑问，为什么我在每个请求后面都加上了一个false？这是因为，我在写这个微信小程序开始时，没有使用easy-mock来模拟http请求数据。我是把假数据都放在mock.js文件中。然后使用 **return request('banners')**这种方式就可以获取我想要的数据。API封装完了，该怎么调用呢？我就以首页的banners数据为例// index.js \r\nconst WXAPI = require('../../wxapi/main')\r\n\r\nonLoad: function (options) {\r\n    WXAPI.showLoading()\r\n    this.getBanners()\r\n},\r\ngetBanners() {\r\n    WXAPI\r\n    .getBanners()\r\n    .then(res => {\r\n      wx.hideLoading()\r\n      this.setData({\r\n        banners: res.data\r\n      })\r\n    })\r\n},\r\n复制代码记住，如果想要发送HTTP请求数据的页面，都必须加上这一句const WXAPI = require('../../wxapi/main')定义的组件开始准备OK,现在开始写页面。第一步要写的是tabBar部分。tabBar组件看起来是不是有点奇怪，为什么有点透明的感觉？因为这个tabBar组件是我自己写的。一般来将，直接在把tabBar组件写在app.json中，就可以了。但是我觉得不是那么好看，所以就自己撸了一个tabBar组件出来。写完之后查文档才发现，微信小程序官方提供了自定义tabBar组件的方法,有需要的可以查看微信小程序文档写完这个组件后我总解了一下,需要注意的问题.选中了的当前页面，再次点击因该无效。所以我在app.js中存入了一个page属性，来存储当前页面，然后在点击事件goToPage()方法中加入判断去解决。<!--components/tabbar/tabbar.wxml-->\r\n<view class=\"tabbar\">\r\n  <!-- 首页 -->\r\n  <view class=\"shouye {{on === 'index' ? 'on': ''}}\" data-page=\"index\" bindtap=\"goToPage\">\r\n    <icon type=\"shouye\" size=\"42\" class=\"icon\" color=\"{{on === 'index' ? '#f96702': ''}}\"/>\r\n    <text >首页</text>\r\n  </view>\r\n  <!-- 分类 -->\r\n  <view class=\"fenlei {{on === 'category' ? 'on': ''}}\" data-page=\"category\" bindtap=\"goToPage\">\r\n    <icon type=\"classify\" size=\"42\" class=\"icon\" color=\"{{on === 'category' ? '#f96702': ''}}\"/>\r\n    <text >分类</text>\r\n  </view>\r\n  <!-- 发现 -->\r\n  <view class=\"faxian {{on === 'find' ? 'on': ''}}\" data-page=\"find\" bindtap=\"goToPage\">\r\n    <icon type=\"faxian\" size=\"42\" class=\"icon\" color=\"{{on === 'find' ? '#f96702': ''}}\"/>\r\n    <text >发现</text>\r\n  </view>\r\n  <!-- 购物车 -->\r\n  <view class=\"gouwuche {{on === 'cart' ? 'on': ''}}\" data-page=\"cart\" bindtap=\"goToPage\">\r\n    <icon type=\"gouwuche\" size=\"42\" class=\"icon\" color=\"{{on === 'cart' ? '#f96702': ''}}\"/>\r\n    <text >购物车</text>\r\n  </view>\r\n  <!-- 我的 -->\r\n  <view class=\"wode {{on === 'user' ? 'on': ''}}\" data-page=\"user\" bindtap=\"goToPage\">\r\n    <icon type=\"wode\" size=\"42\" class=\"icon\" color=\"{{on === 'user' ? '#f96702': ''}}\"/>\r\n    <text >我的</text>\r\n  </view>\r\n</view>\r\n复制代码// components/tabbar/tabbar.js\r\n// 全局里面存了一个page 表示当前 路由\r\nconst app =  getApp();\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 是否选中\r\n    on:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    // 跳转到相应的页面\r\n    // 加了一个判断\r\n    // 因为如果现在显示的是当前页面就不需要再跳转\r\n    goToPage(e) {\r\n      let page = e.currentTarget.dataset.page || 'user';\r\n      if(app.globalData.page === page) {\r\n        return ;\r\n      }\r\n      wx.redirectTo({\r\n        url: `/pages/${page}/${page}`,\r\n      });\r\n      app.globalData.page = page;\r\n    }\r\n  }\r\n})\r\n复制代码/* components/tabbar/tabbar.wxss */\r\n.tabbar {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  background-color: #ffffff;\r\n  display: flex;\r\n  position: fixed;\r\n  bottom: 0;\r\n  font-size: 26rpx;\r\n  z-index: 99;\r\n}\r\n.shouye,.fenlei,.faxian,.gouwuche,.wode {\r\n  flex: 1;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  text-align: center;\r\n  opacity: 0.5;\r\n}\r\n.icon {\r\n  height: 60rpx;\r\n}\r\n.on {\r\n  color:#f96702;\r\n}\r\n复制代码关于如何使用的问题，只需要在，需要tabBar功能的页面底部加上就可以.比如index页面<tabbar on=\"index\"></tabbar>\r\n复制代码记得在json中引入组件{\r\n  \"usingComponents\": {\r\n    \"goodList\": \"../../components/goodList/goodList\",\r\n    \"tabbar\": \"../../components/tabbar/tabbar\"\r\n  }\r\n}\r\n复制代码icon组件tabBar组件中需要图标，我使用的是阿里的图标库如何使用？先去图标库中找到你所需要的图标，加入购物车。然后添加至项目，自己新建一个就可以了。在然后下载之本地，把其中的CSS文件里面所有的内容都复制到wxss文件中就行了.这个组件很简单，定义出来就可以直接使用，并且修改颜色和大小.<!--components/icon/icon.wxml-->\r\n<text class='iconfont icon-{{type}}' style='color:{{color}}; font-size:{{size}}rpx;'></text>\r\n复制代码properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  },\r\n复制代码goodList组件在首页中存在很多这样的商品列表，一个一个写，这样写出来的代码会导致首页的代码显得很多，并且不好维护，所以我就封装成了一个组件.<!--components/goodList/goodList.wxml-->\r\n<view class=\"goodList-good\">\r\n  <!-- 商品的图片 -->\r\n  <view class=\"goodList-good-img\">\r\n    <image src=\"{{url}}\" mode=\"aspectFill\" />\r\n  </view>\r\n  <!-- 商品详细的信息 -->\r\n  <view class=\"goodList-good_detail\">\r\n    <!-- 名称 -->\r\n    <view class=\"good_detail_name\">\r\n      {{name}}\r\n    </view>\r\n    <!-- 信息 -->\r\n    <view class=\"good_detail_brief\">\r\n      {{brief}}\r\n    </view>\r\n    <!-- 价格 -->\r\n    <view class=\"good_detail_price\">\r\n      <text class=\"price\" >￥{{price}}</text>\r\n      <text class=\"oldPrice\" style=\"display:{{oldPrice == '' ? 'none': 'inline'}};\">￥{{oldPrice}}</text>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码properties: {\r\n    // 图片链接\r\n    url: {  \r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 名称\r\n    name: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 信息\r\n    brief: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 新的价格\r\n    price: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    // 旧的价格\r\n    oldPrice: {\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n复制代码/* components/goodList/goodList.wxss */\r\n\r\n.goodList-good {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.goodList-good-img {\r\n  width: 100%;\r\n  height: 312rpx;\r\n  position: relative;\r\n}\r\n.goodList-good-img image {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.goodList-good_detail {\r\n  padding: 26rpx 23rpx;\r\n}\r\n.good_detail_name {\r\n  width:100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  display: -webkit-box;\r\n  -webkit-line-clamp: 1;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.good_detail_brief {\r\n  width:100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  display: -webkit-box;\r\n  -webkit-line-clamp: 1;\r\n  -webkit-box-orient: vertical;\r\n  font-size: 25rpx;\r\n  color: #8c8c8c;\r\n}\r\n.good_detail_price {\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: flex-end;\r\n}\r\n.good_detail_price .price {\r\n  color: #a36d4a;\r\n  font-size: 28rpx;\r\n  padding-right: 16rpx;\r\n}\r\n.good_detail_price .oldPrice {\r\n  font-size: 24rpx;\r\n  color: #8c8c8c;\r\n  text-decoration: line-through;\r\n}\r\n复制代码你们会发现，我的边框为什么那么细。0.5px边框如何画初学者，可能会说，0.5px边框，不就是border: 0.5px吗，其实这是错的。浏览器会把任何小于1px的边框都解析成1px,所以你写0.5px其实浏览器会解析成1px,这样就实现不了效果。其实也很简单， 使用伪类去画。例如，goodList组件的右部边框.在index页面的html中,我在包裹goodList的view标签的class中加上了 rightBorder 这个类来表示画出上边框。<view class=\"item topBorder rightBorder\" data-id=\"{{item.id}}\" bindtap=\"goDetails\">\r\n  <goodList url=\"{{item.url}}\"\r\n    name=\"{{item.name}}\"\r\n    brief=\"{{item.brief}}\"\r\n    price=\"{{item.price}}\"\r\n    oldPrice=\"{{item.oldPrice}}\" ></goodList>\r\n</view>\r\n复制代码.rightBorder::after {\r\n  content: '';\r\n  position: absolute;\r\n  height: 200%;\r\n  width: 1rpx;\r\n  right: -1rpx;\r\n  top: 0;\r\n  transform-origin: 0 0;\r\n  border-right: 1rpx solid#e0e0e0;\r\n  transform: scale(.5);\r\n  z-index: 1;\r\n}\r\n复制代码其实画0.5px边框就记住。使用伪类，并且 position: absolute;如果想画上下的边框，就把width设置成200%,,左右就把height设置成200%然后使用transform: scale(.5); 宽高都缩小0.5倍就成了0.5px边框.其它还有一些 细节问题就按照所需写就行。userList组件只是我的页面中的一个列表信息，这个很简单<!--components/userList/userList.wxml-->\r\n<view class=\"main\">\r\n  <image src=\"{{List.img}}\" />\r\n  <view class=\"text\" >\r\n    <text >{{List.text}}</text>\r\n  </view>\r\n  <view class=\"state\" wx:if=\"{{List.state !== ''}}\">\r\n    <text >({{List.state}})</text>\r\n  </view>\r\n</view>\r\n复制代码/* components/userList/userList.wxss */\r\n.main {\r\n  width: 100%;\r\n  height: 120rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  background-color: #fff;\r\n  padding: 40rpx;\r\n  box-sizing: border-box;\r\n}\r\n.main image {\r\n  width: 80rpx;\r\n  height: 80rpx;\r\n}\r\n.main .text {\r\n  font-size: 32rpx;\r\n  padding: 0 10rpx 0 5rpx;\r\n}\r\n.main .state {\r\n  font-size: 26rpx;\r\n  color: #8c8c8c;\r\n}\r\n复制代码properties: {\r\n    List: {\r\n      type: Object\r\n    }\r\n  },\r\n复制代码页面和功能介绍首页搜索部分我这里引入的是weui组件的搜索样式。如何用?下载 WEUI小程序版 ，可以在微信开发者工具中打开。(推荐)把styly文件夹下的weui.wxss 放到自己项目中weui文件夹下在app.wxss中@import \"./weui/weui.wxss\".就可以使用了首页轮播部分这是微信小程序提供的一个组件swiper,微信小程序开发者文档swiper和swiper-item组合起来就可以实现,一些配置信息，请查看官方文档具体代码<swiper indicator-dots=\"{{indicatorDots}}\" indicator-active-color=\"#ffffff\" autoplay=\"{{autoPlay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n    <block wx:for=\"{{banners}}\" wx:key=\"index\">\r\n      <swiper-item>\r\n        <image src=\"{{item.imgurl}}\" mode=\"aspectFill\" class=\"banner-image\" />\r\n      </swiper-item>\r\n    </block>\r\n  </swiper>\r\n复制代码data: {\r\n    banners: [],\r\n    indicatorDots: true,\r\n    autoPlay: true,\r\n    interval: 3000,\r\n    duration: 1000,\r\n    navdata: [],\r\n    goodList: [],\r\n    goodListOne: {},\r\n    name:'',\r\n  },\r\n复制代码一个常用的功能在商城小程序中经常要做一个这样的功能.例如:功能要求:点击左边的商品列表，右边的商品信息会滑动到对应位置.滑动右边的商品信息，左边的商品列表显示的高亮会对应发生变化.功能要求并不难，但是对于初学者而言，可能会有些问题。我就直接说功能该怎么做首先：分析一下，页面结构是左右布局。并且 两边都可以滑动 .所以可以使用微信给我们提供的scroll-view组件.两个组件就可以采用float，分布在左右两边.<!-- miniprogram/pages/category/category.wxml -->\r\n<view class=\"container\">\r\n  <!-- 左边商品的标签信息 -->\r\n  <scroll-view scroll-y scroll-with-animation=\"{{true}}\" class=\"categroy-left\">\r\n    <view wx:for=\"{{categroy}}\" wx:key=\"{{index}}\" data-index=\"{{index}}\" bindtap=\"switchTab\" class=\"cate-list {{curIndex === index ? 'on': ''}}\">\r\n      {{item[0].name}}\r\n    </view>\r\n  </scroll-view>\r\n  <!-- 右边 标签对应的商品信息 -->\r\n  <scroll-view scroll-y scroll-into-view=\"{{toView}}\" scroll-with-animation=\"true\" bindscroll=\"scrollContent\" bindscrolltolower=\"scrollEnd\" class=\"categroy-right\">\r\n    <block wx:for=\"{{categroy}}\" wx:key=\"inedx\">\r\n      <view id=\"right-list\" class=\"right-list\" id=\"{{index}}\">\r\n        <view class=\"right-title\">\r\n          <text>{{item[0].name}}</text>\r\n        </view>\r\n        <view class=\"right-content\">\r\n          <block wx:for=\"{{item}}\" wx:key=\"idex\" wx:for-item=\"product\" wx:for-index=\"idex\">\r\n            <view class=\"list-detail\" wx:if=\"{{idex > 0}}\">\r\n              <image src=\"{{product.picture}}\" />\r\n              <view class=\"detail-name\">\r\n                <text>{{product.desc}}</text>\r\n              </view>\r\n            </view>\r\n          </block>\r\n        </view>\r\n      </view>\r\n    </block>\r\n  </scroll-view>\r\n</view>\r\n<tabbar on=\"category\"></tabbar>\r\n\r\n复制代码/* miniprogram/pages/category/category.wxss */\r\n/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/\r\n::-webkit-scrollbar\r\n{\r\nwidth: 0px;\r\nheight: 0px;\r\nbackground-color: pink;\r\n}\r\n.categroy-left {\r\n  height: 100%;\r\n  width: 150rpx;\r\n  float: left;\r\n  border-right: 1px solid #ebebeb;\r\n  box-sizing: border-box;\r\n  position: fixed;\r\n  font-size: 30rpx;\r\n  padding-bottom: 100rpx;\r\n  box-sizing: border-box;\r\n}\r\n.categroy-left .cate-list {\r\n  height: 90rpx;\r\n  line-height: 90rpx;\r\n  text-align: center;\r\n  border: 2px solid #fff;\r\n}\r\n.categroy-left .cate-list.on {\r\n  color: #ff4800;\r\n  font-size: 34rpx;\r\n}\r\n/* 右边的列表 */\r\n.categroy-right {\r\n  width: 600rpx;\r\n  float: right; \r\n  height: 1334rpx;\r\n  /* height: 100%; */\r\n  padding-bottom: 100rpx;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n}\r\n.right-title {\r\n  width: 100%;\r\n  text-align: center;\r\n  position: relative;  \r\n  padding-top: 30rpx;\r\n  /* font-size: 30rpx; */\r\n  padding-bottom: 30rpx;\r\n}\r\n .right-title text::before, .right-title text::after {\r\n  content: '';\r\n  position: absolute;\r\n  width: 60rpx;\r\n  /* height: 1px; */\r\n  top: 50%;\r\n  border-top: 1px solid #e0e0e0;\r\n  /* transform: scale(.5); */\r\n}\r\n.right-title text::before { \r\n  left: 30%;\r\n}\r\n.right-title text::after {\r\n  right: 30%;\r\n}\r\n.right-list {\r\n  /* height: 100%; */\r\n  background-color: #fff;\r\n}\r\n.right-content {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n}\r\n.right-content .list-detail {\r\n  flex-shrink: 0;\r\n  width: 33.3%;\r\n  height: 100%;\r\n  font-size: 26rpx;\r\n  text-align: center;\r\n  \r\n}\r\n.right-content .list-detail image {\r\n  width: 120rpx;\r\n  height: 120rpx;\r\n  padding: 10rpx;\r\n  /* background-color: pink; */\r\n}\r\n复制代码这个功能的难点就在于js逻辑先贴出data中需要的数据data: {\r\n    categroy:[],    //商品信息\r\n    curIndex: 'A',  //当前的选中的标签\r\n    toView: 'A',    //去到的标签\r\n    // 存入每个list的高度叠加\r\n    heightArr: [],\r\n    // 最后一个list,就是最后一个标签的id\r\n    endActive: 'A'\r\n  },\r\n复制代码点击左边右边滑动这一功能很简单就能实现只需要在右边scroll-view组件中添加事件 scroll-into-view=\"{{toView}}\" ,toView就是商品显示的 id注意，右边每个商品信息，页面渲染时 必须 加上id属性然后左边的scroll-view组件只需添加一个点击事件去修改toView的值就行了// 点击左边标签要修改的信息\r\n  switchTab(e) {\r\n    this.setData({\r\n      curIndex: e.target.dataset.index,\r\n      toView: e.target.dataset.index\r\n    })\r\n  },\r\n复制代码滑动右边左边高亮对应改变首先需要计算出 右边商品每一块占据的高度,并且存入数组中 ,可以放入onReady生命周期中// 计算出右边每个商品占据的高度\r\n  getPageMessage() {\r\n    // console.log(4)\r\n    let self = this\r\n    let heightArr = []\r\n    let h = 0\r\n    const query = wx.createSelectorQuery()\r\n    query.selectAll('.right-list').boundingClientRect()\r\n    query.exec( res => {\r\n      res[0].forEach( item => {\r\n        h += item.height\r\n        heightArr.push(h)\r\n      })\r\n      self.setData({\r\n        heightArr: heightArr\r\n      })\r\n    })\r\n  },\r\n复制代码在右边的scroll-view组件中加上事件。 bindscroll=\"scrollContent ,这是scroll-view提供的事件,在滑动时就会触发.// 页面滑动时触发\r\n  scrollContent(e) {\r\n    const scrollTop = e.detail.scrollTop\r\n    const scrollArr = this.data.heightArr\r\n    const length = scrollArr.length - 1\r\n    let endChar = String.fromCharCode(65 + length)\r\n    let curChar = this.getCurrentIndex(scrollTop)\r\n    if(this.data.endActive != endChar) {\r\n      this.setData({\r\n        curIndex: curChar\r\n      })\r\n    } else {\r\n      this.setData({\r\n        endActive: 'A'\r\n      })\r\n    }\r\n  },\r\n复制代码// 判断curIndex应该是那个\r\n  getCurrentIndex(scrollTop) {\r\n    const scrollArr = this.data.heightArr\r\n    let find = scrollArr.findIndex(item => {\r\n      // 提前10rpx触发效果\r\n      return scrollTop < item - 10\r\n    })\r\n    let curChar = String.fromCharCode(65 + find)\r\n    return curChar\r\n  },\r\n复制代码以上就可以实现所有的功能要求了。但是这样的滑动并不是很完美，右边滑动到最下面，左边高亮却不是最后一个相对完美效果就是这样想要完美一点就要在，右边scroll-view添加一个事件： bindscrolltolower=\"scrollEnd\"// 页面滑动到底部触发\r\n  scrollEnd() {\r\n    const scrollArr = this.data.heightArr\r\n    const length = scrollArr.length - 1\r\n    let endChar = String.fromCharCode(65 + length)\r\n    this.setData({\r\n      curIndex: endChar,\r\n      endActive: endChar\r\n    })\r\n  },\r\n复制代码购物逻辑想要实现这样的效果并不困难。逻辑顺序: 首页点击商品信息 -> 商品详情页面显示对应的商品详情信息 -> 购物车页面显示商品购买的商品信息. -> 修改之后，商品详情页面显示修改的信息。想要实现这样的功能，必须有一个 id 在页面跳转时，传入给跳转的页面，跳转的页面再通过id值获取页面所需的数据例如：首页 -> 商品详情页这是一条商品的列表的信息,通过点击事件 bindtap=\"goDetails\" ，跳到对应的页面.<view class=\"list\">\r\n      <block wx:for=\"{{goodList}}\" wx:key=\"{{item.id}}\">\r\n        <view class=\"item topBorder rightBorder\" data-id=\"{{item.id}}\" bindtap=\"goDetails\">\r\n          <goodList url=\"{{item.url}}\"\r\n            name=\"{{item.name}}\"\r\n            brief=\"{{item.brief}}\"\r\n            price=\"{{item.price}}\"\r\n            oldPrice=\"{{item.oldPrice}}\" ></goodList>\r\n        </view>  \r\n      </block>\r\n    </view>\r\n复制代码goDetails(e) {\r\n    const id = e.currentTarget.dataset.id\r\n    wx.navigateTo({\r\n      url: `/pages/goodDetails/goodDetails?id=${id}`,\r\n    });\r\n  },\r\n复制代码商品详情页:传入的 id值 可以再onLoad生命周期的options参数上获取onLoad: function (options) {\r\n    WXAPI.showLoading()\r\n    // 获取用户的地址信息\r\n    const address = wx.getStorageSync('Address');\r\n    this.setData({\r\n      id: options.id,\r\n      address\r\n    })\r\n    this.getGoodDetail()\r\n  },\r\n复制代码数据的存储逻辑我是把数据直接存在本地缓存中(也可以直接存入到云数据库中)，使用的是 wx.setStorage()在本地存入了两个数据， 一个是所有购买的商品信息，一个是总的商品购买数量// 添加到购物车\r\n  toAddCart() {\r\n    let cartData = wx.getStorageSync('goods') || [];    \r\n    let data = {\r\n      id: this.data.id,\r\n      name: this.data.goodData.name,\r\n      memory: this.data.memory,\r\n      color: this.data.color,\r\n      price: this.data.price,\r\n      num: this.data.selectNum,\r\n      img: this.data.imgSrc,\r\n      select: true\r\n    }\r\n    // wx.removeStorageSync('goods');\r\n    cartData.push(data)\r\n    const allNum =this.getAllNum(cartData)\r\n    wx.setStorage({\r\n      key: 'goods',\r\n      data: cartData,\r\n      success: (res) => {\r\n        console.log(res)\r\n        let pageIndex = getCurrentPages()\r\n        let backIndex = pageIndex.length - 2\r\n        wx.navigateBack({\r\n          delta: backIndex\r\n        })\r\n      },\r\n      fail: () => {},\r\n      complete: () => {}\r\n    });\r\n    // 存储数量到storage\r\n    wx.setStorageSync('allNum', allNum);\r\n    // 写到外面就可以让showToast 显示在前一个页面\r\n    setTimeout(()=>{\r\n      wx.showToast({\r\n        title: '已加入购物车',\r\n        icon: 'success',\r\n        duration: 2000\r\n      });\r\n   },500)\r\n  },\r\n  // 获取所有的数量\r\n  getAllNum(cartData) {\r\n    return cartData.reduce((sum, item) => {\r\n      return sum + (+item.num)\r\n    },0)\r\n  },\r\n复制代码概述的参数切换实现这个功能只需要加一个状态，点击时就修改状态的值，并且修改相关渲染的数据就行。data: {\r\n state: 'details_img', //判断概述 参数\r\n}\r\n复制代码<view class=\"summarize-parameter\">\r\n    <view class=\"title\">\r\n      <view class=\"summarize\" bindtap=\"changeState\">\r\n        <text class=\"{{state === 'details_img'? 'on' : ''}}\">概述</text>\r\n      </view>\r\n      <view class=\"parameter\" bindtap=\"changeState\">\r\n        <text class=\"{{state === 'param_img'? 'on' : ''}}\">参数</text>\r\n      </view>\r\n    </view>\r\n    <view class=\"state\">\r\n      <block wx:for=\"{{state === 'details_img'? details_img : param_img}}\" wx:key=\"index\">\r\n          <image src=\"{{item}}\" mode=\"widthFix\"/>\r\n      </block>\r\n    </view>\r\n  </view>\r\n复制代码// 改变概述和参数\r\n  changeState() {\r\n    let state = this.data.state\r\n    if(state === 'details_img') {\r\n      state = 'param_img'\r\n    } else {\r\n      state = 'details_img'\r\n    }\r\n    this.setData({\r\n      state\r\n    })\r\n  },\r\n复制代码购物数据改变，商品详情数据修改对比一下上面两张图的区别.在购物页面中选的商品数量和具体的商品信息，之后跳转回商品详情页面中,对应的数据会修改<view class=\"sales\" bindtap=\"goSelectGoods\">\r\n      <text class=\"describe\">已选</text>\r\n      <view class=\"detail detail-change\">\r\n        {{default_change.name}}\r\n        {{default_change.memory}}\r\n        {{default_change.color}}\r\n        <text >× {{default_change.num}}</text>\r\n      </view>\r\n      <view class=\"right\"></view>\r\n    </view>\r\n复制代码<view class=\"shopping-img\" bindtap=\"goCart\">\r\n    <icon type=\"gouwuche\" color=\"#e0e0e0\" size=\"40\"/>\r\n    <text wx:if=\"{{allNum != 0}}\">{{allNum}}</text>\r\n  </view>\r\n复制代码上面时两块修改的html结构在购物页面点击确认之后，我默认就把商品添加到购物车中，并且位于数据的最后一条返回商品详情页面时，会重新触发onShow生命周期的函数。所以我只需要，在onShow中触发修改方法就行.// 改变默认的版本数据 default_change\r\n  changeDefauleChange() {\r\n    const goods = wx.getStorageSync('goods') || [];\r\n    if(goods.length === 0) {\r\n      return\r\n    }\r\n    const id = this.data.id\r\n    const default_change = goods[goods.length - 1]\r\n    let memory = default_change.memory.toString()\r\n    memory = memory.substring(0,memory.length - 4)\r\n    default_change.memory = memory\r\n    this.setData({\r\n      default_change\r\n    })\r\n  },\r\n复制代码画一个三角形这一个三角形是使用CSS画出来的，并不是图标。使用CSS画出一个三角形，也不是那么困难。使用的是伪类和border属性.right:before,\r\n.right:after {\r\n  content: '';\r\n  position: absolute;\r\n  top: 35%;\r\n  right: 0;\r\n  border-width: 8px;\r\n  /* transform: translateY(10000rpx); */\r\n  border-color: transparent transparent transparent transparent;\r\n  border-style: solid;\r\n  transform: rotate(90deg);\r\n}\r\n\r\n.right:before {\r\n  border-bottom: 8px #aaaaaa solid;\r\n}\r\n\r\n.right:after {\r\n  right: 1px;\r\n  /*覆盖并错开1px*/\r\n  border-bottom: 8px #fff solid;\r\n}\r\n复制代码修改商品数量可以直接使用微信小程序提供的picker组件，具体配置请查看文档使用腾讯地图获取地理位置先搜索腾讯地图，并且注册开发者信息，申请一个密钥key.// 获取地理位置\r\nconst geocoder = (lat, lon) => {\r\n  return request(API.MAPURL,false,{\r\n    location: `${lat},${lon}`,\r\n    key: API.QQ_MAP_KEY,\r\n    get_poi: 0\r\n  })\r\n}\r\n复制代码然后把密钥复制，因为我封装了所有的API接口。所以使用了 API.QQ_MAP_KEY 代替，这里就填写申请的密钥就行.想要获取用户的经纬度信息，可以使用 wx.getLocation() ，就可以获取用户的经纬度信息了.getLocation() {\r\n    wx.getLocation({\r\n      type: 'gcj02',\r\n      success: this.getAddress,\r\n      fail: () => {\r\n        this.openLocation()\r\n      }\r\n    })\r\n  },\r\n  getAddress(res) {\r\n    let { latitude: lat, longitude: lon} = res\r\n    WXAPI.geocoder(lat, lon)\r\n    .then(res => {\r\n      if(res.status !== 0 || !res.result) {\r\n        return\r\n      } \r\n      let {address_component\r\n      } = res.result\r\n      const Address = {\r\n        city: address_component.city,\r\n        district: address_component.district\r\n      }\r\n      wx.setStorageSync(\"Address\", Address);\r\n    })\r\n  },\r\n复制代码因为我未让用户授权，所以直接把获取的地理位置，保存在本地storage中.获取的地理位置，就可以在商品详情页面的送至显示出来结语做这个项目的过程来说是快乐的，没有使用云函数(页面数据并不多，我觉得不需要就可以写出来了)，所以总共加起来写的时间也很短，不到一个星期就写完了。写完之后的那一刻的成就感也很好。如果你觉得这篇文章有帮到你的地方，不妨给个赞吧！同时也非常希望在下方看到给出的建议！最后奉上 源码 .如果有需要就自取吧!最后，说点题外话，因为我是2020届的毕业生，现在面临实习压力。因为需要话时间去看面试题，所以后面写的一段文章，我只是简要的把重要的功能逻辑写了出来，如果写的不清楚，请见谅。"}
{"title": "小程序稻草人图床神器，前后端开源 ", "author": "Rolan", "pubtime": "2019-7-11 00:09", "content": "源码地址：小程序源码 https://github.com/w77996/mini-straw  \r\n后台源码 https://github.com/w77996/hi-straw  \r\n复制代码体验一下之前乘着换工作的间隙撸的，一方面练习一下小程序，学过之后没怎么应用，一方面写点笔记啥的，项目断断续续做了两个月，只是一个简单的图片上传工具，觉得不错的话记得给个star小程序小程序授权，登录父组件与子组件相互通信小程序分享，意见与建议，客服功能，文件上传flex布局的使用Promise的使用，业务model封装插槽的使用，动画效果项目目录结构mini-straw\r\n    ├── component -- 组件\r\n    |    ├── file -- 文件组件\r\n    |    ├── image-button -- 图片按钮组件\r\n    |    ├── search -- 查找页面组件\r\n    |    ├── tag -- 标签组件\r\n    ├── images -- 图片目录\r\n    |    ├── icon -- icon图片\r\n    |    ├── tab -- tab图片\r\n    ├── model -- 封装的model\r\n    ├── pages -- 页面\r\n    |    ├── about -- 关于页\r\n    |    ├── auth -- 授权页\r\n    |    ├── file -- 文件页\r\n    |    ├── index -- 首页\r\n    |    ├── launch -- 启动页面\r\n    |    ├── my -- 个人中心\r\n    └── utils -- 工具\r\n复制代码后台：技术栈：spring boot + druid + mybatis + jwt微信登录，jwt授权注解及AOP的使用maven多环境打包，docker使用shell脚本自动化部署nginx反向代理及https配置七牛云文件操作项目目录结构hi-straw\r\n├── common -- 公共模块\r\n├── config -- 配置模块\r\n├── controller -- controller接口\r\n├── core -- 核心业务模块\r\n|    ├── annontaion -- 注解\r\n|    ├── aop -- aop实现\r\n|    ├── constant -- 常量\r\n|    ├── filter -- 拦截器\r\n|    ├── jwt -- jwt相关\r\n|    └── result -- 结果返回\r\n├── entity -- 实体类\r\n|    ├── dto -- 数据传输\r\n|    └── vo -- 页面传输\r\n├── exception -- 全局异常\r\n├── mapper -- dao层\r\n├── service -- service层\r\n└── util -- 工具类\r\n\r\n复制代码小程序详解[TOC]mini-straw项目结构mini-straw\r\n    ├── component -- 组件\r\n    |    ├── file -- 文件组件\r\n    |    ├── image-button -- 图片按钮组件\r\n    |    ├── search -- 查找页面组件\r\n    |    ├── tag -- 标签组件\r\n    ├── images -- 图片目录\r\n    |    ├── icon -- icon图片\r\n    |    ├── tab -- tab图片\r\n    ├── model -- 封装的model\r\n    ├── pages -- 页面\r\n    |    ├── about -- 关于页\r\n    |    ├── auth -- 授权页\r\n    |    ├── file -- 文件页\r\n    |    ├── index -- 首页\r\n    |    ├── launch -- 启动页面\r\n    |    ├── my -- 个人中心\r\n    └── utils -- 工具\r\n\r\n复制代码开屏页1.判断网络状态使用 wx.getNetworkType({}) 可获取当前网络状态， networkType 值 wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)//判断网络状态\r\nwx.getNetworkType({\r\n    success: res => {\r\n    if (res.networkType == \"none\") {\r\n        wx.showToast({\r\n            title: '嗷~~网络不可用',\r\n            icon: 'none',\r\n            duration: 2000\r\n        })\r\n        return;\r\n    }\r\n    },\r\n})\r\n复制代码2.判断授权状态使用 wx.getSetting({}) 获取授权状态，在获得 data 后取 data.authSetting['scope.userInfo'] 判断授权状态// 获取授权的状态\r\nwx.getSetting({\r\n    success: data => {\r\n    if (data.authSetting['scope.userInfo']) {\r\n        //已授权，执行登陆\r\n        wx.getUserInfo({\r\n            success: data => {\r\n                    console.log(\"userInfo {}\", data)\r\n                    let userInfo = data.userInfo;\r\n                    wx.setStorageSync('userInfo', userInfo);\r\n                    //执行登陆操作\r\n                    this._userLoginGetCode(userInfo);\r\n            }\r\n        });\r\n        wx.setStorageSync('authorized', true);\r\n    } else {\r\n        console.log(\"未授权\")\r\n        //跳转至授权页\r\n        let timer = setTimeout(() => {\r\n                wx.redirectTo({\r\n                        url: '/pages/auth/auth'\r\n                })\r\n        }, 2000)\r\n\r\n    }\r\n    }\r\n});\r\n复制代码若授权，则调用 wx.getUserInfo({}) 获取微信用户信息，信息获取完成后调用 wx.login({})获取小程序的 code ,通过 code 向后台获取用户openId及token。//后台获取code\r\n_userLoginGetCode(userInfo) {\r\n    console.log(\"发起_userLoginGetCode请求\");\r\n    wx.login({\r\n        success(res) {\r\n        console.log(\"wx.login {}\", res);\r\n        if (res.code) {\r\n            // 发起网络请求\r\n            const code = res.code;\r\n            userInfo.code = code;\r\n            userModel.getTokenByCode(userInfo).then((res) => {\r\n                console.log(\"userModel getUserInfo {}\", res);\r\n                wx.setStorageSync(\"token\", res.data.data.token);\r\n                let timer = setTimeout(() =>\r\n                    wx.switchTab({\r\n                            url: '/pages/index/index',\r\n                    }), 2000)\r\n            });\r\n        } else {\r\n                console.log('登录失败！' + res.errMsg)\r\n        }\r\n        }\r\n    })\r\n},\r\n复制代码3.跳转页面跳转 /pages/auth/auth 页面使用的是 wx.redirectTo({})跳转 /pages/index/index 页面使用的是 wx.switchTab({}) 因为 /pages/index/index 是小程序tab页，使用 wx.redirectTo({}) 无法跳转授权页授权需制定button按钮，加入 open-type='getUserInfo' 属性， bindgetuserinfo 调用自定义方法 onGetUserInfo 。<button class=\"auth-button\" open-type='getUserInfo' bindgetuserinfo=\"onGetUserInfo\">好的</button>\r\n复制代码onGetUserInfo 接受授权状态及授权获取的用户信息，再进行 code 获取，通过 code 向后台获取用户openId及token。onGetUserInfo: function(e) {\r\n    console.log(e)\r\n    const userInfo = e.detail.userInfo;\r\n    if (userInfo) {\r\n            //通过`code`向后台获取用户openId及token。\r\n            this._userLoginGetCode(userInfo);\r\n    }\r\n},\r\n复制代码主页1. 图片按钮插槽组件在 component 目录下的 images-button 组件，做了简单的图片插槽统一，在分享按钮，用户登录按钮，文件上传按钮均可以使用。 plain=\"{{true}}\" 代表button背景透明<button  open-type=\"{{openType}}\" plain=\"{{true}}\" class=\"container\">\r\n  <slot name=\"img\"></slot>\r\n</button>\r\n复制代码options 需要开启插槽功能，添加 multipleSlots: true open-type=\"{{openType}}\" 父组件将参数传入子组件，子组件在 properties 属性中可以获取到父组件传来的openType数据，通过 this.properties.openType 可以获取属性值options: {\r\n    // 开启插槽\r\n    multipleSlots: true\r\n  },\r\n/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    openType: {\r\n      type: String\r\n    }\r\n  },\r\n复制代码index 页面引入组件，需要在 index.json 中添加组件路径{\r\n  \"usingComponents\": {\r\n    \"btn-cmp\": \"/component/image-button/index\"\r\n  }\r\n}\r\n复制代码2. 上传文件主要使用到 wx.chooseImage({}) 进行图片的选择，选择后使用 wx.uploadFile({}) 上传图片至服务器//上传文件\r\nonUpload(event) {\r\nlet _this = this;\r\nwx.chooseImage({\r\n  count: 1, // 默认9\r\n  sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n  success: function(res) {\r\n    // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n    let tempFilePaths = res.tempFilePaths;\r\n    console.log(tempFilePaths)\r\n    wx.uploadFile({\r\n      header: {\r\n        \"Authorization\": \"Bearer \" + wx.getStorageSync(\"token\")\r\n      },\r\n      url: config.apiBaseUrl + '/file/upload',\r\n      filePath: tempFilePaths[0],\r\n      name: 'file',\r\n      success: (res) => {\r\n        wx.showToast({\r\n          title: \"上传成功~\",\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n      },\r\n      fail: (res) => {\r\n        wx.showToast({\r\n          title: res.data.msg,\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n}\r\n复制代码列表页1.search组件的显示和隐藏固定列表页搜索header位置，点击header显示 search 组件，在 search 组件点击取消则隐藏 search 组件，此处设计子组件向父组件传递消息引入search组件\"usingComponents\": {\r\n    ...\r\n    \"search-cmp\": \"/component/search/index\"\r\n  }\r\n复制代码使用searchPage参数判断 search 组件的,默认为false,在点击header时更新searchPage为true,显示 search 组件<view wx:if=\"{{!searchPage}}\" class=\"container\">\r\n  ...\r\n</view>\r\n\r\n<search-cmp  wx:if=\"{{searchPage}}\" ></search-cmp>\r\n复制代码search 页面点击取消，向父组件发送一个 this.triggerEvent('cancel', {}, {}); 事件，在xml中的 search-cmp 添加 cancel 事件的通知绑定#file页面中的search-cmp组件\r\n<search-cmp  wx:if=\"{{searchPage}}\" bind:cancel=\"onCancel\"></search-cmp>\r\n复制代码父组件 file 页面绑定子组件传来的 cancel 事件通知，就调用 onCancel 方法, 在 onCancel方法中获取事件响应，将 searchPage 参数修改为false， search 组件就隐藏起来了//cancel searching page \r\nonCancel(event) {\r\n  console.info(event)\r\n  this.triggerEvent('cancel', {}, {});\r\n \r\n},\r\n复制代码2.文件列表1.获取列表信息传递给file组件在 page 中的file页面，获取到后台传来的fileList数据，引入file组件， file=\"{{item}}\" 将数据传入子组件<view wx:if=\"{{fileList}}\">\r\n  <block wx:for=\"{{fileList}}\" wx:key=\"{{item.id}}\" file=\"{{item}}\">\r\n    <file-cmp file=\"{{item}}\" bind:del=\"onDelete\"></file-cmp>\r\n    <view class=\"line\"></view>\r\n  </block>\r\n</view>\r\n复制代码在 component 中的file组件，在 properties 添加属性 file 来接收父组件传来的数据/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    file: Object\r\n  }\r\n复制代码file组件在xml页面中使用 {{file.fileName}} 即可获取到对象信息，相应的数据也会呈现在页面上3.粘贴板操作<image src=\"images/copy.png\" bindtap=\"onCopy\"></image>\r\n复制代码图片点击响应方法 onCopy ， onCopy 调用 wx.setClipboardData({}) 可以将数据复制到粘贴板onCopy: function (event) {\r\n      console.info(event)\r\n      let _this = this;\r\n      wx.setClipboardData({\r\n        data: _this.properties.file.filePath,\r\n        success: function(res) {\r\n          wx.showToast({\r\n            title: '图片地址复制成功',\r\n          })\r\n        }\r\n      });\r\n\r\n复制代码4.删除操作<image src=\"images/del.png\" bindtap=\"onDelete\"></image>\r\n复制代码子组件将数据传递给父组件，点击删除图片出发 onDelete 方法,通过 this.triggerEvent('del', {fileId}, {}); 将文件ID发送到父组件onDelete: function (event) {\r\n      console.info(event)\r\n      let fileId = this.properties.file.id;\r\n      this.triggerEvent('del', {fileId}, {});\r\n    },\r\n复制代码父组件file页面绑定子组件传来的 del 事件<file-cmp file=\"{{item}}\" bind:del=\"onDelete\"></file-cmp>\r\n复制代码调用 onDelete 出发网络请求去完成删除文件的逻辑,删除成功后重新刷新文件列表//删除图片\r\nonDelete(event) {\r\n    console.info(\"DEL\")\r\n    console.info(event)\r\n    let fileId = event.detail.fileId;\r\n    fileModel.delFileById(fileId).then((res) => {\r\n        console.info(res);\r\n        wx.showToast({\r\n                title: '删除成功',\r\n        })\r\n        this.setData({\r\n                pageNum: 1,\r\n                fileList: []\r\n        });\r\n        this._getFileList();\r\n    })\r\n},\r\n复制代码我的页面1.意见和建议小程序自带用户反馈功能，使用 button 跳转至网页，用户可以填写相关反馈, open-type 设置为 feedback<button class=\"about-btn\" plain=\"true\" open-type=\"feedback\">\r\n    <text class=\"about-btn-text\">反馈建议</text>\r\n</button>\r\n复制代码2.小程序客服小程序的 button 中的 open-type 拥有开放能力,在微信公众平台中启用客服功能，添加客服人员，在代码中添加 button 即可弹出客服聊天界面, open-type 设置为 contact<button class=\"about-btn\" plain=\"true\" open-type=\"contact\" bindcontact=\"handleContact\">\r\n    <text class=\"about-btn-text\">联系客服</text>\r\n</button>\r\n复制代码3.小程序分享此处使用插槽, button 中的 open-type 设置为 share<btn-cmp open-type=\"share\">\r\n    <image slot=\"img\" src=\"images/share.png\" />\r\n</btn-cmp>\r\n复制代码动画小程序动画官方文档开屏动画，设置文字透明度，从0到1，渐渐显示，主要使用到 opacity 去设置组件的透明度，先创建一个动画 animationTip ,持续800ms,然后在 setTimeout(function () {}) 中设置动画出现时间var animationTip = wx.createAnimation({\r\n      //持续时间800ms\r\n      duration: 800,\r\n      timingFunction: 'ease',\r\n    });\r\n    this.animationTip = animationTip;\r\n    animationTip.opacity(0).step()\r\n    this.setData({\r\n      animationTip: animationTip.export()\r\n    })\r\n    setTimeout(function () {\r\n      animationTip.opacity(1).step()\r\n      this.setData({\r\n        animationTip: animationTip.export()\r\n      })\r\n    }.bind(this), 500)\r\n复制代码部署修改 utils 目录下的 config.apiBaseUrl ,改成自己的域名，上传到微信公众号平台，在版本管理中进行发布const config ={\r\n   apiBaseUrl: \"你自己的域名或服务器地址\"\r\n}\r\n复制代码后台功能详解hi-straw项目结构hi-straw\r\n├── common -- 公共模块\r\n├── config -- 配置模块\r\n├── controller -- controller接口\r\n├── core -- 核心业务模块\r\n|    ├── annontaion -- 注解\r\n|    ├── aop -- aop实现\r\n|    ├── constant -- 常量\r\n|    ├── filter -- 拦截器\r\n|    ├── jwt -- jwt相关\r\n|    └── result -- 结果返回\r\n├── entity -- 实体类\r\n|    ├── dto -- 数据传输\r\n|    └── vo -- 页面传输\r\n├── exception -- 全局异常\r\n├── mapper -- dao层\r\n├── service -- service层\r\n└── util -- 工具类\r\n\r\n复制代码数据库设计CREATE TABLE `t_straw_file` (\r\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) UNSIGNED DEFAULT NULL COMMENT '用户ID',\r\n  `file_path` varchar(255) DEFAULT NULL COMMENT '文件路径',\r\n  `file_name` varchar(100) DEFAULT NULL COMMENT '文件名',\r\n  `file_size` varchar(10) DEFAULT NULL COMMENT '文件大小',\r\n  `props` varchar(255) DEFAULT NULL,\r\n  `status` tinyint(5) UNSIGNED DEFAULT '0' COMMENT '0.正常 -1.删除',\r\n  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT'创建时间',\r\n  PRIMARY KEY (`id`),\r\n    KEY `user_id` (`user_id`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8mb4 COMMENT '用户文件列表';\r\n复制代码CREATE TABLE `t_straw_user` (\r\n  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,\r\n  `user_name` varchar(20) DEFAULT NULL COMMENT '用户名',\r\n  `nickname` varchar(20) DEFAULT NULL COMMENT '用户昵称',\r\n  `user_logo` varchar(250) DEFAULT NULL COMMENT '用户logo',\r\n  `phone_num` varchar(20) DEFAULT NULL COMMENT '手机号',\r\n  `open_id` varchar(55) DEFAULT NULL COMMENT '微信openId',\r\n  `union_id` varchar(20) DEFAULT NULL COMMENT '微信union_id',\r\n  `password` varchar(50) DEFAULT NULL COMMENT '密码',\r\n  `uuid` varchar(20) DEFAULT NULL COMMENT '自定义生成的uuid',\r\n  `last_login` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '最后登陆时间',\r\n\t`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  PRIMARY KEY (`id`),\r\n\tUNIQUE KEY `open_id` (`open_id`) USING HASH\r\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COMMENT '用户表';\r\n复制代码CREATE TABLE `t_straw_user_file_info` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) UNSIGNED NOT NULL COMMENT '用户ID',\r\n  `file_size` int(11) UNSIGNED DEFAULT '0' COMMENT '用户文件大小',\r\n  `left_size` int(11) UNSIGNED DEFAULT '5242880' COMMENT '剩余文件大小',\r\n  `total_size` int(11)UNSIGNED DEFAULT '5242880' COMMENT '用户文件空间大小',\r\n  `file_num` int(11) UNSIGNED DEFAULT '0' COMMENT '文件数量',\r\n  `is_vip` tinyint(5) UNSIGNED DEFAULT '0' COMMENT '是否为vip,1.是 0.否',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `user_id` (`user_id`) USING HASH\r\n) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8mb4 COMMENT'用户文件信息';\r\n复制代码CREATE TABLE `t_straw_user_info` (\r\n  `user_id` int(11)  UNSIGNED NOT NULL COMMENT '用户ID',\r\n  `sex` tinyint(5) UNSIGNED DEFAULT NULL COMMENT '性别',\r\n  `location` varchar(55) DEFAULT NULL COMMENT '位置',\r\n  `platform` varchar(55) DEFAULT NULL COMMENT '平台',\r\n  `birthday` datetime DEFAULT NULL COMMENT '生日',\r\n  PRIMARY KEY (`user_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户详细表';\r\n复制代码代码详解前期准备linux服务器及MySql数据库七牛云账号，可以去七牛云官网申请账号HTTPS证书阿里云获取免费证书微信公众平台小程序开发者账号七牛云文件上传代码 com.w77996.straw.util.QiNiuUtil1.七牛云账号申请七牛云官网申请账号，获得 AccessKey , SecretKey ,并设置七牛云图片 bucket/**\r\n     * 七牛accessKey\r\n     */\r\n    @Value(\"${QiNiu.accessKey}\")\r\n    private String accessKey;\r\n    /**\r\n     * 七牛密钥\r\n     */\r\n    @Value(\"${QiNiu.secretKey}\")\r\n    private String secretKey;\r\n    /**\r\n     * 七牛bucket\r\n     */\r\n    @Value(\"${QiNiu.bucket}\")\r\n    private String bucket;\r\n复制代码2.七牛云SDK引入pom.xml 文件引入七牛云仓库<dependency>\r\n        <groupId>com.qiniu</groupId>\r\n        <artifactId>qiniu-java-sdk</artifactId>\r\n        <version>[7.2.0, 7.2.99]</version>\r\n    </dependency>\r\n复制代码2. 七牛云token生成/**\r\n     * 七牛云生成token\r\n     *\r\n     * @param fileName\r\n     * @return\r\n     */\r\n    public QiNiuAuth generateToken(String userId, String fileName) {\r\n        Auth auth = Auth.create(accessKey, secretKey);\r\n        String key = \"upload/file/000/\" + userId + \"/\" + fileName;\r\n        StringMap putPolicy = new StringMap();\r\n        putPolicy.put(\"returnBody\", \"{\\\"key\\\":\\\"$(key)\\\",\\\"hash\\\":\\\"$(etag)\\\",\\\"bucket\\\":\\\"$(bucket)\\\",\\\"fsize\\\":$(fsize)}\");\r\n        long expireSeconds = 3600;\r\n        String upToken = auth.uploadToken(bucket, key, expireSeconds, putPolicy);\r\n        Map<String, String> resultMap = Maps.newHashMapWithExpectedSize(3);\r\n        resultMap.put(\"domain\", \"https://www.w77996.cn\");\r\n        resultMap.put(\"key\", key);\r\n        resultMap.put(\"upToken\", upToken);\r\n        return new QiNiuAuth(\"https://www.w77996.cn\", key, upToken);\r\n    }\r\n复制代码3.上传文件代码编写/**\r\n     * 上传图片\r\n     *\r\n     * @param file\r\n     * @param key\r\n     * @param token\r\n     * @return\r\n     */\r\n    public String uploadImage(MultipartFile file, String key, String token) {\r\n        Configuration cfg = new Configuration(Zone.zone2());\r\n        UploadManager uploadManager = new UploadManager(cfg);\r\n        String filePath = null;\r\n        //生成上传凭证，不指定key的情况下，以文件内容的hash值作为文件名\r\n        Response response = null;\r\n        try {\r\n            byte[] uploadBytes = file.getBytes();\r\n            Auth auth = Auth.create(accessKey, secretKey);\r\n            String upToken = auth.uploadToken(bucket);\r\n            try {\r\n                response = uploadManager.put(uploadBytes, key, upToken);\r\n                //解析上传成功的结果\r\n                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);\r\n                log.info(\"上传结果 {} {}\", putRet.hash, putRet.key);\r\n                filePath = putRet.key;\r\n            } catch (QiniuException ex) {\r\n                try {\r\n                    response = ex.response;\r\n                    log.error(response.bodyString());\r\n                } catch (QiniuException ex2) {\r\n                    //ignore\r\n                    ex.printStackTrace();\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            //ignore\r\n            ex.printStackTrace();\r\n        }\r\n        return filePath;\r\n    }\r\n复制代码4.删除图片/**\r\n     * 删除图片\r\n     *\r\n     * @param key\r\n     */\r\n    public void delete(String key) {\r\n        Configuration cfg = new Configuration(Zone.zone2());\r\n        Auth auth = Auth.create(accessKey, secretKey);\r\n        //实例化一个BucketManager对象\r\n        BucketManager bucketManager = new BucketManager(auth, cfg);\r\n        try {\r\n            //调用delete方法移动文件\r\n            bucketManager.delete(bucket, key);\r\n        } catch (QiniuException e) {\r\n            //捕获异常信息\r\n            throw new GlobalException(ResultCode.ERROR);\r\n        }\r\n    }\r\n复制代码注解+AOP接口限流1. 注解编写代码 com.w77996.straw.core.annotation.Limiter@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\npublic @interface Limiter {\r\n\r\n    /**\r\n     *\r\n     * @return\r\n     */\r\n    String value() default \"\";\r\n\r\n    /**\r\n     * 每秒向桶中放入令牌的数量   默认最大即不做限流\r\n     * @return\r\n     */\r\n    double perSecond() default Double.MAX_VALUE;\r\n\r\n    /**\r\n     * 获取令牌的等待时间  默认0\r\n     * @return\r\n     */\r\n    int timeOut() default 0;\r\n\r\n    /**\r\n     * 超时时间单位\r\n     * @return\r\n     */\r\n    TimeUnit timeOutUnit() default TimeUnit.MILLISECONDS;\r\n}\r\n\r\n复制代码2.AOP实现代码 com.w77996.straw.core.aop.RateLimitAspect@Aspect\r\n@Component\r\n@Slf4j\r\npublic class RateLimitAspect {\r\n\r\n    private RateLimiter rateLimiter = RateLimiter.create(Double.MAX_VALUE);\r\n\r\n    /**\r\n     * 定义切点\r\n     * 1、通过扫包切入\r\n     * 2、带有指定注解切入\r\n     */\r\n    @Pointcut(\"@annotation(com.w77996.straw.core.annotation.Limiter)\")\r\n    public void checkPointcut() {\r\n    }\r\n\r\n    @ResponseBody\r\n    @Around(value = \"checkPointcut()\")\r\n    public Object aroundNotice(ProceedingJoinPoint pjp) throws Throwable {\r\n        log.info(\"拦截到了{}方法...\", pjp.getSignature().getName());\r\n        Signature signature = pjp.getSignature();\r\n        MethodSignature methodSignature = (MethodSignature) signature;\r\n        //获取目标方法\r\n        Method targetMethod = methodSignature.getMethod();\r\n        if (targetMethod.isAnnotationPresent(Limiter.class)) {\r\n            //获取目标方法的@Limiter注解\r\n            Limiter limiter = targetMethod.getAnnotation(Limiter.class);\r\n            rateLimiter.setRate(limiter.perSecond());\r\n            if (!rateLimiter.tryAcquire(limiter.timeOut(), limiter.timeOutUnit())) {\r\n                log.info(\"rateLimiter lock\");\r\n                return Result.error(ResultCode.BUSY);\r\n            }\r\n        }\r\n        return pjp.proceed();\r\n    }\r\n}\r\n复制代码3. 注解使用限定每秒只能调用一次，如果超出，则返回 Result.error(ResultCode.BUSY)@GetMapping(\"/limit\")\r\n    @Limiter(perSecond = 1.0, timeOut = 500)\r\n    public String testLimiter() {\r\n        return \" success\";\r\n    }\r\n复制代码JWT实现1.jwt生成使用JwtUtil生成jwt Token/**\r\n     * 生成jwt\r\n     *\r\n     * @param userId\r\n     * @return\r\n     */\r\n    public static String createJWT(String userId) {\r\n        String token = JwtHelper.createJWT(userId, Constant.JWT_CLIENT_ID,\r\n                Constant.JWT_NAME, Constant.JWT_EXPIRES_SECOND, Constant.JWT_BASE64_SECRET);\r\n        return token;\r\n    }\r\n复制代码2.token解析成userId将userId放入token中，在请求接口时可以通过请求Header获取Bearer {token}进行解码，从而获取userId。/**\r\n     * 通过token获取用户信息\r\n     *\r\n     * @return\r\n     */\r\n    public String getUserIdByToken() {\r\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\r\n        String accessToken = request.getHeader(\"Authorization\");\r\n        if (StringUtils.isEmpty(accessToken) || accessToken.length() < 20) {\r\n            throw new GlobalException(ResultCode.ERROR_TOKEN_NULL);\r\n        }\r\n        accessToken = accessToken.substring(7);\r\n        if (\"admin\".equals(accessToken)) {\r\n            return \"1\";\r\n        }\r\n        Claims claims = JwtHelper.parseJWT(accessToken, Constant.JWT_BASE64_SECRET);\r\n        return claims.getSubject();\r\n    }\r\n复制代码3.拦截器+注解方式进行token鉴权代码 com.w77996.straw.core.annotation.IgnoreToken 先设置忽略token的注解/**\r\n * @description: 忽略token\r\n * @author: w77996\r\n **/\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(value={ElementType.METHOD,ElementType.TYPE})\r\npublic @interface IgnoreToken {\r\n}\r\n复制代码代码 com.w77996.straw.core.filter.TokenFilter 拦截器 TokenFilter 实现 HandlerInterceptor ，在每次请求进来时进行拦截,在调用controller之前都会调用 perHandle ,所以在 perHandler 内获取方法名的注解，判断是否有ignoreToken的注解，然后进行jwt的校验。@Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\r\n        IgnoreToken ignoreToken = handlerMethod.getBeanType().getAnnotation(IgnoreToken.class);\r\n        log.info(\"enter preHandle {}\",request.getRequestURL());\r\n        if (ignoreToken == null) {\r\n            ignoreToken = handlerMethod.getMethodAnnotation(IgnoreToken.class);\r\n        }\r\n        if (ignoreToken != null) {\r\n            log.info(\"ignoreToken not null\");\r\n            return true;\r\n        }\r\n        log.info(\"ignoreToken  null\");\r\n        String token = request.getHeader(\"Authorization\");\r\n        if(token != null){\r\n            log.info(\"token is {}\",token);\r\n            if (\"admin\".equals(token.substring(7))) {\r\n                return true;\r\n            }\r\n            Claims claims = JwtHelper.parseJWT(token.substring(7), Audience.BASE64SECRET);\r\n            if(claims != null){\r\n                log.info(\"claims is {} {}\",claims.toString(),claims.getSubject());\r\n                return true;\r\n            }else{\r\n                log.info(\"claims is null\");\r\n                throw new GlobalException(ResultCode.ERROR_AUTH);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n复制代码4.实现web拦截器代码 com.w77996.straw.config.WebMvcAdapterConfig 不拦截 /druid/* 的接口/**\r\n * @description: web拦截器\r\n * @author: w77996\r\n **/\r\n@Component\r\npublic class WebMvcAdapterConfig extends WebMvcConfigurationSupport {\r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        registry.addInterceptor(new TokenFilter()).excludePathPatterns(\"/druid/*\");\r\n    }\r\n}\r\n复制代码Druid监控配置代码 com.w77996.straw.config.DruidConfig 项目运行后访问 http://ip:port/druid ,输入账号 admin 密码 amdin 即可访问@Configuration\r\npublic class DruidConfig {\r\n\r\n    @Bean\r\n    @ConfigurationProperties(\"spring.datasource\")\r\n    public DataSource druidDataSource() {\r\n        DruidDataSource dataSource = new DruidDataSource();\r\n        return dataSource;\r\n    }\r\n\r\n    @Bean\r\n    public ServletRegistrationBean druidStatViewServlet() {\r\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\r\n        // IP白名单 (没有配置或者为空，则允许所有访问)e\r\n        registrationBean.addInitParameter(\"allow\", \"\");\r\n        // IP黑名单 (存在共同时，deny优先于allow)\r\n        registrationBean.addInitParameter(\"deny\", \"\");\r\n        registrationBean.addInitParameter(\"loginUsername\", \"admin\");\r\n        registrationBean.addInitParameter(\"loginPassword\", \"admin\");\r\n        registrationBean.addInitParameter(\"resetEnable\", \"false\");\r\n        return registrationBean;\r\n    }\r\n\r\n    @Bean\r\n    public FilterRegistrationBean druidWebStatViewFilter() {\r\n        FilterRegistrationBean registrationBean = new FilterRegistrationBean(new WebStatFilter());\r\n        registrationBean.addInitParameter(\"urlPatterns\", \"/*\");\r\n        registrationBean.addInitParameter(\"exclusions\", \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\");\r\n        return registrationBean;\r\n    }\r\n}\r\n复制代码全局异常拦截全局异常拦截主要是依靠 @RestControllerAdvice 注解，在方法上使用 @ExceptionHandler(value = Exception.class) 代表拦截所有Exception,然后进行对应的操作@RestControllerAdvice\r\npublic class GlobalExceptionHandler {\r\n\r\n    /**\r\n     * 全局错误拦截\r\n     *\r\n     * @param e\r\n     * @return\r\n     */\r\n    @ExceptionHandler(value = Exception.class)\r\n    private Result<Object> exceptionHandler(Exception e) {\r\n        if (e instanceof GlobalException) {\r\n            GlobalException ex = (GlobalException) e;\r\n            return Result.error(ex.getCode());\r\n        }\r\n        return Result.error(ResultCode.ERROR.getCode(),e.getMessage());\r\n    }\r\n}\r\n复制代码微信登录需要在微信公共平台获取对应的appId,appSec，小程序获取到code之后发送给后台，后台获取code向微信发送http请求，使用的是restTemplate,但是需要注意编码，微信编码返回是ISO-8859-1；调用成功后可以拿到用户的openId,再去数据库中获取对应的用户信息，进行登陆更新及用户创建的逻辑处理@RestController\r\n@RequestMapping(\"/wx\")\r\n@Slf4j\r\npublic class WxController {\r\n\r\n    @Autowired\r\n    private IUserService iUserService;\r\n\r\n    @Value(\"${wx.appId}\")\r\n    private String wxAppId;\r\n\r\n    @Value(\"${wx.appSec}\")\r\n    private String wxAppSec;\r\n\r\n    /**\r\n     * 通过code获取openId\r\n     *\r\n     * @param wxLoginDto\r\n     * @return\r\n     */\r\n    @IgnoreToken\r\n    @PostMapping(\"/code\")\r\n    public Result getUserInfoByCode(@RequestBody WxLoginDto wxLoginDto) {\r\n        log.info(\"enter getUserInfoByCode\");\r\n        //微信授权获取openId\r\n        String reqUrl = \"https://api.weixin.qq.com/sns/jscode2session?appid=\" + wxAppId + \"&secret=\" + wxAppSec + \"&js_code=\" + wxLoginDto.getCode() + \"&grant_type=authorization_code\";\r\n        JSONObject wxAuthObject = RestHttpClient.client(reqUrl, HttpMethod.GET, null);\r\n        log.info(\"wxAuthObject {}\", wxAuthObject.toJSONString());\r\n        WxTokenDto wxTokenDto = JSONObject.parseObject(wxAuthObject.toJSONString(), WxTokenDto.class);\r\n        log.info(\"wxTokenDto {}\", wxTokenDto.toString());\r\n        Map<String, Object> tokenMapper = Maps.newHashMapWithExpectedSize(2);\r\n        //生成新用户\r\n        UserEntity userEntity = iUserService.getUserByOpenId(wxTokenDto.getOpenid());\r\n        if (!ObjectUtils.allNotNull(userEntity)) {\r\n            WxUserInfoDto wxUserInfoDto = new WxUserInfoDto();\r\n            wxUserInfoDto.setNickname(wxLoginDto.getNickName());\r\n            wxUserInfoDto.setUserLogo(wxLoginDto.getUserLogo());\r\n            wxUserInfoDto.setSex(wxLoginDto.getSex());\r\n            wxUserInfoDto.setLastLogin(new Date());\r\n            wxUserInfoDto.setOpenId(wxTokenDto.getOpenid());\r\n            wxUserInfoDto.setLocation(StringUtils.join(new String[]{wxLoginDto.getCountry(), wxLoginDto.getProvince(), wxLoginDto.getCity()}, \"-\"));\r\n            iUserService.createNewUser(wxUserInfoDto);\r\n            log.info(\"create new user {}\", wxUserInfoDto);\r\n        }\r\n        tokenMapper.put(\"token\", JwtHelper.createJWT(userEntity.getId() + \"\"));\r\n        return Result.success(tokenMapper);\r\n    }\r\n}\r\n复制代码spring boot + maven多环境打包1.resouce下的yml文件项目环境分为 dev 和 prod 两种， resource 文件下默认加载 application.yml 。application.yml\r\nspring:\r\n    profiles:\r\n      active: @spring.profiles.active@\r\n复制代码@spring.profiles.active@ 对应的为pom.xml文件中profiles下的 spring.profiles.active 属性2.pom.xml配置默认情况下使用 dev 环境下的配置信息<profiles>\r\n        <profile>\r\n            <id>dev</id>\r\n            <activation>\r\n                <activeByDefault>true</activeByDefault>\r\n            </activation>\r\n            <properties>\r\n                <!-- default Spring profiles -->\r\n                <spring.profiles.active>dev</spring.profiles.active>\r\n            </properties>\r\n        </profile>\r\n        <profile>\r\n            <id>prod</id>\r\n            <properties>\r\n                <!-- default Spring profiles -->\r\n                <spring.profiles.active>prod</spring.profiles.active>\r\n            </properties>\r\n        </profile>\r\n    </profiles>\r\n复制代码3.不同环境打包打包 prod 环境：执行 mvn package -Pprod -DskipTests打包 dev 环境：执行 mvn package -Pdev -DskipTests4.项目打包命名在 properties 属性中添加时间格式，然后再 build 中添加 fileName 格式化文件名。<artifactId>hi-straw</artifactId>\r\n    <version>1.0.0</version>\r\n    <properties>\r\n        ...\r\n        <maven.build.timestamp.format>yyyy-MM-ddHHmm</maven.build.timestamp.format>\r\n    </properties>\r\n    <build>\r\n        ...\r\n        <finalName>\r\n            ${project.artifactId}-${project.version}-${spring.profiles.active}_${maven.build.timestamp}\r\n        </finalName>\r\n    </build>\r\n\r\n复制代码打包完成后生成的jar： hi-straw-1.0.0-prod_2019-04-091533.jarshell脚本编写登陆服务器，clone项目至 /root/repo_git/ 目录下,执行进入 script 目录下，执行 ./build.sh ，需要将 RELEASE_HOST 换成你自己的服务器地址，方便做保存备份#!/bin/sh\r\nset -e\r\n#打包的服务器地址\r\nRELEASE_HOST=\"你自己的服务器地址\"\r\n#打包的环境\r\nRELEASE_ENV=prod\r\n#项目目录\r\nBASE_DIR=/root/repo_git/Histraw\r\n#进入项目目录\r\ncd ${BASE_DIR}\r\n#执行git拉去最新的代码\r\necho \"pulling changes...\"\r\ngit pull origin master\r\necho \"pulling changes... finish\"\r\necho \"building...\"\r\n#执行mvn命令打包\r\nmvn clean\r\nmvn package -P${RELEASE_ENV} -DskipTests docker:build\r\necho \"building...finish\"\r\necho \"env =${RELEASE_ENV}\"\r\n#for HOST in ${RELEASE_HOST}; do\r\n#进行拷贝及备份\r\nRELEASE_TARGET=root@${RELEASE_HOST}:~/release/\r\necho \"copying to $RELEASE_TARGET...\"\r\nscp ${BASE_DIR}/target/*.jar ${RELEASE_TARGET}\r\necho \"copying to $RELEASE_TARGET...done\"\r\n#done\r\n复制代码执行 docker images查看刚刚打包好的docker镜像maven + docker 打包部署1.docker环境安装卸载老旧的版本（若未安装过可省略此步）：sudo apt-get remove docker docker-engine docker.io\r\n复制代码安装最新的docker：curl -fsSL get.docker.com -o get-docker.sh\r\nsudo sh get-docker.sh\r\n复制代码确认Docker成功安装：docker run hello-world\r\n复制代码2.项目编译打包在 src/main/docker 下建立 dockerFile 文件FROM openjdk:8-jdk-alpine\r\nVOLUME /tmp\r\nADD *.jar app.jar\r\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]\r\n复制代码pom.xml配置docker打包，配合shell脚本在linux实现maven自动打包docker<!-- Docker maven plugin -->\r\n    <plugin>\r\n        <groupId>com.spotify</groupId>\r\n        <artifactId>docker-maven-plugin</artifactId>\r\n        <version>1.0.0</version>\r\n        <configuration>\r\n            <imageName>${project.artifactId}</imageName>\r\n            <dockerDirectory>src/main/docker</dockerDirectory>\r\n            <resources>\r\n                <resource>\r\n                    <targetPath>/</targetPath>\r\n                    <directory>${project.build.directory}</directory>\r\n                    <include>${project.build.finalName}.jar</include>\r\n                </resource>\r\n            </resources>\r\n        </configuration>\r\n    </plugin>\r\n<!-- Docker maven plugin -->\r\n复制代码执行 docker images 查看刚刚打包的docker镜像执行 docker run --name hi-straw -p 8989:8989 -t hi-straw 启动镜像执行 dockers ps 查看已启动docker镜像nginx配置https1.安装nginx登陆到服务器，执行$ apt-get update // 更新软件\r\n$ apt-get install nginx // 安装nginx\r\n复制代码2. 获取证书可以去阿里云获取免费证书将生成的证书放入 /etc/nginx/sites-enabled/cert/ (具体看你将nginx安装在哪个目录下)3. 配置nginx文件新建一个https.confserver {\r\n    listen 443;\r\n    server_name 你自己的域名;\r\n    ssl on;\r\n    ssl_certificate  cert/你自己的证书.pem;\r\n    ssl_certificate_key cert/你自己的证书.key;\r\n    ssl_session_timeout 5m;\r\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\r\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\r\n    ssl_prefer_server_ciphers on;\r\n    location / {\r\n        #项目部署的ip和端口\r\n    \tproxy_pass http://localhost:port;\r\n\r\n    }\r\n}\r\n复制代码配置完成后，检查一下nginx配置文件是否可用nginx -t //检查nginx配置文件\r\n复制代码配置正确后，重新加载配置文件使配置生效nginx -s reload //使配置生效\r\n复制代码如需重启nginx，用以下命令：service nginx stop //停止\r\nservice nginx start //启动\r\nservice nginx restart //重启\r\n复制代码部署修改 resource 下的 application-dev.yml 和 application-prod.yml 中你自己申请的微信息及七牛云信息修改，修改数据库地址，用户名和密码#七牛\r\nqiNiu:\r\n  accessKey: 你申请的七牛云key\r\n  secretKey: 你申请的七牛云sec\r\n  bucket: 你申请的七牛云bucket\r\n  domain: 你申请的七牛云domain\r\n#微信\r\nwx:\r\n  appId: 你申请的微信id\r\n  appSec: 你申请的微信sec\r\n复制代码spring:\r\n  datasource:\r\n    name: graduate\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n    url: 数据库地址\r\n    username: 数据库用户名\r\n    password: 数据库密码\r\n复制代码修改 script 目录下 build.shRELEASE_HOST=\"你自己的服务器地址\"\r\n复制代码项目的服务器7月15号到期了……哪位大佬资助一下服务器，感激不尽捐助"}
{"title": "微信小程序探险记 - 生成图片分享 ", "author": "Rolan", "pubtime": "2019-7-11 00:32", "content": "前言\r\n最近几天作者一直在忙着开发一个C端微信小程序商城项目(wepy 1.7.x, 不得不吐槽坑超级多，被虐的不要不要的，下个版本打算 taro + ts 重构, 差点被逼疯了..)\r\n今天就有个生成图片分享的需求，需要实现。具体探险经历如下\r\n业务需求\r\n\r\n如图所示，在点击保存的时候，生成上方的图片并保存。\r\n具体实现\r\n\r\n需要保存的区域要用canvas绘制，之后使用wx.canvasToTempFilePath 生成本地图片 以及 wx.saveImageToPhotosAlbum 保存图片\r\n\r\n1. 创建 canvas 画布\r\n<canvas\r\n  class=\"home-share__canvas\" // 内部添加样式，主要是宽高\r\n  canvas-id=\"shareCanvas\"\r\n/>\r\n复制代码2. 绘制画布\r\nconst ctx = wx.createCanvasContext('shareCanvas')\r\n// banner图\r\nctx.drawImage('../../../assets/share/banner.png', 0, 0, 240, 40)\r\nctx.drawImage('../../../assets/share/title.png', 82, 9.5, 76, 21)\r\n\r\n// 画矩形\r\nctx.setFillStyle('white')\r\nctx.fillRect(0, 40, 240, 240)\r\n\r\nctx.setFillStyle('white')\r\nctx.fillRect(0, 280, 240, 100)\r\n\r\n// 价格文字\r\nctx.setFillStyle('#ff0136') // 文字颜色：黑色\r\nctx.setFontSize(30) // 文字字号：22px\r\n\r\nctx.font = 'bold 30px DIN Alternate' // 字体可以这样设置样式\r\nctx.fillText('996', 20, 300)\r\n\r\n......\r\n\r\nctx.stroke()\r\nctx.draw()\r\n复制代码3. 生成图片\r\nwx.canvasToTempFilePath({\r\n  canvasId: 'shareCanvas',\r\n  success: function(res) {\r\n    console.log(res.tempFilePath) // 生成的图片地址\r\n  }\r\n})\r\n复制代码4. 保存图片\r\nsaveImageToPhotosAlbum(imgUrl) { // imgUrl 即是上方的 res.tempFilePath\r\n    if (imgUrl) {\r\n        wx.saveImageToPhotosAlbum({\r\n            filePath: imgUrl,\r\n            success: res => {\r\n              wx.showToast({\r\n                title: '保存成功',\r\n                icon: 'success',\r\n                duration: 2000\r\n              })\r\n            },\r\n            fail: err => {\r\n              wx.showToast({\r\n                title: '保存失败',\r\n                icon: 'none',\r\n                duration: 2000\r\n              })\r\n            }\r\n        })\r\n    } else {\r\n      wx.showToast({\r\n        title: '绘制中……',\r\n        icon: 'loading',\r\n        duration: 3000\r\n      })\r\n    }\r\n}\r\n复制代码\r\nps: 需要授权 writePhotosAlbum, 中间需要加入授权的逻辑\r\n\r\nSo Easy\r\n别人写了一半的项目, 持续踩坑中..."}
{"title": "小程序生成海报代码分享 ", "author": "Rolan", "pubtime": "2019-7-12 00:21", "content": "最近趁垃圾分类这个热点，做了一个小程序，里面有一个模块是答题活动，题目答完之后，会生成分数海报，具体如下图所示这里涉及微信小程序的几个知识点如下获取用户个人信息授权保存图片到本地授权canvas文件操作以及下面几个APIwx.getImageInfowx.downloadFilewx.saveFilewx.createCanvasContextwx.canvasToTempFilePathwx.getSettingwx.saveImageToPhotosAlbumwx.authorizewx.saveImageToPhotosAlbum获取背景图片promiseBdImg: function(){\r\n    const _this = this\r\n    const bdImagePath = '../../static/images/common/'\r\n    return new Promise(function (resolve, reject) {\r\n      wx.getImageInfo({\r\n        src: bdImagePath + \"base.png\",\r\n        success: function (res) {\r\n          console.log('promiseBdImg', res)\r\n          resolve(res);\r\n        },\r\n        fail: function(err){\r\n          console.log('2019062007');\r\n          console.log(err);\r\n        }\r\n      })  \r\n    });\r\n  },将背景图片onReady: function () {\r\n    const _this = this\r\n\r\n    //默认进入页面就生成背景图\r\n    var windowWidth = this.data.windowWidth;\r\n    var posterHeight = this.data.posterHeight;\r\n    this.promiseBdImg().then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      //主要就是计算好各个图文的位置\r\n      ctx.drawImage('../../' + res.path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n      ctx.save() // 对当前区域保存\r\n      ctx.draw()\r\n\r\n    }).then( () => {\r\n    \r\n    })    \r\n  },生成海报图片generateImage: function(e){\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    let userInfo = e.detail.userInfo\r\n    console.log('userInfo', userInfo)\r\n    // 更新用户信息\r\n    // api.post('更新用户信息的url', userInfo)\r\n    this.setData({\r\n      userInfo: e.detail.userInfo\r\n    });\r\n\r\n    console.log('2019062006');\r\n    // 头像\r\n    // let promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n    //   resolve(wx.getStorageSync('avatarUrl'))\r\n    // }).catch(res=>{\r\n    //   console.log('catch',res)\r\n    // });\r\n\r\n    wx.showLoading({\r\n      title: '正在生成海报，请稍后'\r\n    })\r\n\r\n    let avatarUrl = userInfo.avatarUrl;\r\n    let nickName = userInfo.nickName;\r\n    let promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n      wx.getImageInfo({\r\n        src: avatarUrl,\r\n        success: function (res) {\r\n          console.log('promiseAvatarImg', res)\r\n          resolve(res);\r\n        },\r\n        fail: function(err){\r\n          console.log('2019070501');\r\n          console.log(err);\r\n        }\r\n      })  \r\n    });\r\n\r\n    const _this = this\r\n\r\n    const qrImagePath = '../../qrcode/'\r\n    let promiseQrcodeImg = new Promise(function (resolve, reject) {\r\n      wx.getImageInfo({\r\n        src: qrImagePath + \"gh_d2778c07ec2e_258.jpg\",\r\n        success: function (res) {\r\n          console.log('promiseQrcodeImg', res)\r\n          resolve(res);\r\n        },\r\n        fail: function(err){\r\n          console.log('2019062007');\r\n          console.log(err);\r\n        }\r\n      })  \r\n    });    \r\n\r\n    var windowWidth = this.data.windowWidth;\r\n    var posterHeight = this.data.posterHeight;\r\n    Promise.all([\r\n      promiseAvatarUrl, promiseQrcodeImg\r\n    ]).then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      //主要就是计算好各个图文的位置\r\n      \r\n      ctx.drawImage(res[0].path,148, 10, 75, 75, 0, 0) // 把图片填充进裁剪的圆形\r\n      ctx.restore() // 恢复\r\n      ctx.save()\r\n      \r\n      ctx.beginPath() // 开始新的区域\r\n      ctx.drawImage('../../' + res[1].path, 128, 266, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\n      ctx.restore() // 恢复\r\n      ctx.save()\r\n\r\n      ctx.beginPath();\r\n      ctx.setTextAlign('center')\r\n      ctx.setFillStyle('#000')\r\n      ctx.setFontSize(22)      \r\n      ctx.fillText('得分'+_this.data.score, 180, 250)\r\n      ctx.setFontSize(18) \r\n      ctx.fillText('欢迎'+ nickName +'参加垃圾分类答题活动', 180, 414)\r\n      ctx.stroke()\r\n      ctx.draw(true)\r\n\r\n    }).then( () => {\r\n      wx.hideLoading()\r\n    })\r\n  },将海报图片保存到本地图片如下所示saveImage: function(){\r\n    var windowWidth = this.data.windowWidth;\r\n    var posterHeight = this.data.posterHeight;\r\n\r\n    var _this = this\r\n    wx.showLoading({\r\n      title: '正在保存海报，请稍后'\r\n    })\r\n    new Promise(function (resolve, reject) {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: windowWidth*2,\r\n        height: posterHeight*2,\r\n        destWidth: windowWidth*2,\r\n        destHeight: posterHeight*2,\r\n        canvasId: 'shareImg',\r\n        success: function (res) {\r\n          console.log(res.tempFilePath);\r\n          _this.setData({\r\n            prurl: res.tempFilePath,\r\n            hidden: false\r\n          })\r\n          resolve(res)\r\n        },\r\n        fail: function (res) {\r\n          console.log(res)\r\n        }\r\n      })\r\n    }).then(res => {\r\n      console.log(res)\r\n      this.save(res)\r\n    })\r\n  },具体代码请移步 https://gitee.com/jgl1210/laj...有不懂得可以在评论区留言"}
{"title": "微信小程序底层架构 ", "author": "Rolan", "pubtime": "2019-7-12 00:47", "content": "从技术的发展角度来看，微信小程序是从微信中的 webView 和 JS-SDK 进化到了今天的形态。那么，小程序和普通的 h5 页面到底有什么区别呢？运行环境：小程序基于浏览器内核重构的内置解析器，而 h5 的宿主环境是浏览器。所以小程序中没有 DOM 和 BOM 的相关 API ， jQuery 和一些 NPM 包都不能在小程序中使用；系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等；渲染机制：小程序的逻辑层和渲染层是分开的，而 h5 页面 UI 渲染跟 JavaScript 的脚本执行都在一个单线程中，互斥。所以 h5 页面中长时间的脚本运行可能会导致页面失去响应。其实，小程序开发过程中我们面对的是 iOS 和 Android 微信客户端和辅助开发的小程序开发者工具。根据官方文档，这三大运行环境也是有所区别的：运行环境逻辑层渲染层iOSJavaScriptCoreWKWebViewAndroidX5 JSCoreX5浏览器小程序开发者工具NWJSChrome WebView所以微信小程序介于 web 端和原生 App 之间，能够丰富调用功能接口，同时又跨平台。2. 小程序架构2.1 双线程模型小程序的渲染层和逻辑层分别由2个线程管理：渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。逻辑层：采用 JsCore 线程运行JS脚本。视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。（页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面）双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。2.2 组件系统我们知道小程序是有自己的组件的，这些基本组件就是基于 Exparser 框架。 Exparser 基于 WebComponents 的 ShadowDOM 模型，但是不依赖浏览器的原生支持，而且可在 纯 JS 环境中运行。小程序中，所有节点树相关的操作都依赖于 Exparser ，包括 WXML 到页面最终节点树的构建、 CreateSelectorQuery 调用和自定义组件特性等。现在微信小程序也支持自定义组件了，用法和组件间通信类似于 Vue 。2.3 原生组件在内置组件中，有一些组件并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染。比如说 Map 组件。它渲染的层级比在 WebView 层渲染的普通组件要高。引入原生组件的优点是：Web\r\nWebView\r\nsetData\r\n2.4 运行机制2.4.1 启动热启动：：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。2.4.2 销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。2.5 更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用 wx.getUpdateManager 做个检查更新的功能：checkNewVersion() {\r\n    const updateManager = wx.getUpdateManager();\r\n    updateManager.onCheckForUpdate((res) => {\r\n      console.log('hasUpdate', res.hasUpdate);\r\n      // 请求完新版本信息的回调\r\n      if (res.hasUpdate) {\r\n        updateManager.onUpdateReady(() => {\r\n          this.setData({\r\n            hasNewVersion: true\r\n          });\r\n        });\r\n      }\r\n    });\r\n  }\r\n复制代码微信小程序的基础底层架构大概就这么多，有机会再看看源码思考解析吧。"}
{"title": "[打怪升级]小程序评论回复和发贴功能实战（一） ", "author": "Rolan", "pubtime": "2019-7-12 00:23", "content": "在学习成长的过程中，常常会遇到一些自己从未接触的事物，这就好比是 打怪升级 ，每次打倒一只怪，都会获得经验，让自己进步强大。特别是我们这些做技术的， 逆水行舟不进则退 。下面分享下小程序开发中的 打怪升级 经历~先来看下实际效果图，小程序开发中有时会要做一些的功能复杂的组件，比如评论回复和发帖功能等，这次主要讲的是关于 评论模块 的一些思路和实战中的经验，希望能抛砖引玉，给大家一些启发，一同成长~>> （最下面有实战demo的地址，可以直接浏览器打开添加至IDE工具中） <<根据这个demo.gif，本人做了一个简单的流程图，帮助大家理解。下面罗列一些开发中需要“ 打的怪 ”：1、组件目录结构├─components      ---小程序自定义组件\r\n│  ├─plugins      --- （重点）可独立运行的大型模块，可以打包成plugins\r\n│  │  ├─comment         ---评论模块\r\n│  │  │  │  index.js\r\n│  │  │  │  index.json\r\n│  │  │  │  index.wxml\r\n│  │  │  │  index.wxss\r\n│  │  │  │  services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n         │      \r\n         └─submit    ---评论模块子模块：提交评论\r\n                 index.js\r\n                 index.json\r\n                 index.wxml\r\n                 index.wxss为什么要单独做个 评论页面页面（submit） ？因为如果是当前页面最下面input输入的形式，会出现一些兼容问题，比如：不同手机的虚拟键盘高度不同，不好 绝对定位 和完全适配弹窗输入框过小输入不方便，如果是大的textare时，容易误触下面评论的交。注：目录结构，仅供参考。2、NODE端API接口返回结构和页面结构//node：API接口返回\r\n{\r\n    \"data\": {\r\n        \"commentTotal\": 40,\r\n        \"comments\": [\r\n            {\r\n                \"contentText\": \"喜欢就关注我\",   //评论内容\r\n                \"createTime\": 1560158823647,    //评论时间\r\n                \"displayName\": \"智酷方程式\",       //用户名\r\n                \"headPortrait\": \"https://blz.nosdn.127.net/1/weixin/zxts.jpg\",  //用户头像\r\n                \"id\": \"46e0fb0066666666\",  //评论ID  用于回复和举报\r\n                \"likeTotal\": 2,    //点赞数\r\n                \"replyContents\": [   //回复评论\r\n                    {\r\n                        \"contentText\": \"@智酷方程式  喜欢就回复我\",   //回复评论内容\r\n                        \"createTime\": 1560158986524,   //回复时间\r\n                        \"displayName\": \"神秘的前端开发\",   //回复的用户名\r\n                        \"headPortrait\": \"https://blz.nosdn.127.net/1/2018cosplay/fourth/tesss.jpg\",  //回复的用户头像\r\n                        \"id\": \"46e0fb00111111111\",   //回复评论的ID\r\n                        \"likeTotal\": 2,    //回复评论的点赞数\r\n                        \"replyContents\": [],   //回复的回复 盖楼\r\n                        \"replyId\": \"46e0fb001ec222222222\",   //回复评论的独立ID，用于统计\r\n                    },\r\n                    {\r\n                        \"contentText\": \"@智酷方程式： 威武，学习学习\",\r\n                        \"createTime\": 1560407232814,\r\n                        \"displayName\": \"神秘的前端开发\",\r\n                        \"headPortrait\": \"https://blz.nosdn.127.net/1/2018cosplay/fourth/tesss.jpg\",\r\n                        \"id\": \"46e0fb00111111111\",\r\n                        \"likeTotal\": 0,\r\n                        \"replyContents\": [],\r\n                        \"replyId\": \"46e0fb001ec222222222\",\r\n                    }\r\n                ],\r\n                \"replyId\": \"\",\r\n                \"topicId\": \"46e0fb001ec3333333\",\r\n            }\r\n        ],\r\n        \"curPage\": 1,  //当前页面\r\n        //通过ID 判断  当前用户点赞了 哪些评论\r\n        \"likes\": [\r\n            \"46e0fb00111111111\",    \r\n            \"46e0fb001ec222222222\",\r\n            \"46e0fb0066666666\",\r\n        ],\r\n        \"nextPage\": null, //下一页\r\n        \"pageSize\": 20,  //一页总共多少评论\r\n        \"total\": 7,   //总共多少页面\r\n    },\r\n    \"msg\": \"success\",\r\n    \"status\": \"success\"\r\n}<!-- HTML 部分 -->\r\n<block wx:if=\"{{commentList.length>0}}\">\r\n    <!-- 评论模块 -->\r\n    <block wx:for=\"{{commentList}}\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"idx\">\r\n        <view class=\"commentItem\" catchtap=\"_goToReply\" data-contentid=\"{{item.id}}\" data-replyid=\"{{item.id}}\"\r\n            data-battle-tag=\"{{item.displayName}}\">\r\n            <view class=\"titleWrap\">\r\n                <image class=\"logo\" src=\"{{item.headPortrait||'默认图'}}\"></image>\r\n                <view class=\"authorWrap\">\r\n                    <view class=\"author\">{{item.displayName}}</view>\r\n                    <view class=\"time\">{{item.createTime}}</view>\r\n                </view>\r\n                <view class=\"starWrap\" catchtap=\"_clickLike\" data-index=\"{{index}}\" data-like=\"{{item.like}}\"\r\n                    data-contentid=\"{{item.id}}\" data-topicid=\"{{item.topicId}}\">\r\n                    <text class=\"count\">{{item.likeTotal||\"\"}}</text>\r\n                    <view class=\"workSprite icon {{item.like?'starIconHasClick':'starIcon'}}\"></view>\r\n                </view>\r\n            </view>\r\n            <view class=\"text\">\r\n                {{item.contentText}}\r\n            </view>\r\n        </view>\r\n        <!-- 评论的评论 -->\r\n        <block wx:for=\"{{item.replyContents}}\" wx:for-item=\"itemReply\" wx:for-index=\"indexReply\" wx:key=\"idxReply\">\r\n            <view class=\"commentItem commentItemReply\" catchtap=\"_goToReply\" data-contentid=\"{{itemReply.id}}\"\r\n                data-replyid=\"{{item.id}}\" data-battle-tag=\"{{itemReply.displayName}}\">\r\n                ... 和上面类似\r\n            </view>\r\n        </block>\r\n    </block>\r\n    <!-- 加载更多loading -->\r\n    <block wx:if=\"{{isOver}}\">\r\n        <view class=\"more\">评论加载完成</view>\r\n    </block>\r\n</block>通过node提供一个API接口，通过用户的openId来判断是否点赞，这里提供一个 参考的JSON结构。JSON尽量做成array循环的结构方便渲染，根据ID来BAN人和管理。底部加上加载更多的效果，同时，记得做一些兼容，比如默认头像等。3、评论中的一些微信原生交互这里建议很多交互如果不是必须要特别定制，可以才用微信原生的组件，效果和兼容性都有保障，而且方便简单。对评论进行回复/举报<!-- HTML部分 通过绑定事件：_goToReply 进行交互-->\r\n<view class=\"commentItem\" catchtap=\"_goToReply\" data-contentid=\"{{item.id}}\" data-replyid=\"{{item.id}}\"\r\n    data-battle-tag=\"{{item.displayName}}\">\r\n    ... 内部省略\r\n</view>//JS部分  微信原生wx.showActionSheet 显示操作菜单交互\r\n_goToReply(e) {\r\n    //  上面的各种授权判断省略...\r\n    let self = this;\r\n    wx.showActionSheet({\r\n        itemList: ['回复', '举报'],\r\n        success: function (res) {\r\n            if (!res.cancel) {\r\n                console.log(res.tapIndex);\r\n                //前往评论\r\n                if (res.tapIndex == 0) {\r\n                    //判断是否是 评论的评论\r\n                    self._goToComment(replyid);\r\n                }\r\n                //举报按钮\r\n                if (res.tapIndex == 1) {\r\n                    //弹出框\r\n                    self.setComplain(contentid);\r\n                }\r\n            } else { //取消选择\r\n                \r\n            }\r\n        },\r\n        fail(res) {\r\n            console.log(res.errMsg)\r\n        }\r\n    });\r\n}\r\n//当选择“举报”的时候，二次调用 wx.showActionSheet 方法\r\nsetComplain(contentid){\r\n    let complainJson = [\"敏感信息\", \"色情淫秽\", \"垃圾广告\", \"语言辱骂\", \"其它\"];\r\n    wx.showActionSheet({\r\n        itemList: complainJson,\r\n        success: async res => {\r\n            if (!res.cancel) {\r\n                //选择好后，提交举报\r\n                try {\r\n                    let complainResult = await request.postComplainReport(complainJson[index], openid, contentid);\r\n                    if (complainResult.msg == \"success\") {  //提交成功后反馈\r\n\r\n                    } else {\r\n\r\n                    }\r\n                } catch (e) {\r\n                    console.log(e)\r\n                }\r\n            }\r\n        }\r\n    });\r\n}显示操作菜单 wx.showActionSheet 方法说明属性类型说明itemListArray.<string>按钮的文字数组，数组长度最大为 6itemColorstring按钮的文字颜色successfunction接口调用成功的回调函数failfunction接口调用失败的回调函数completefunction接口调用结束的回调函数（调用成功、失败都会执行）使用这个方法，即是主流的做法，也能很好的兼容不同机型，同时给予用户“习惯性体验”。原生评论排序切换<!-- picker组件  html部分-->\r\n<picker bindchange=\"bindPickerChange\" value=\"{{index}}\" range=\"{{array}}\">\r\n    <view class=\"picker\">\r\n        当前选择：{{array[index]}}\r\n    </view>\r\n</picker>// js部分\r\nPage({\r\n    data:{\r\n        //查看评论类型切换\r\n        array: [\"最佳\", \"最新\", \"只看自己\"],\r\n        //选择数组中的第几个显示\r\n        index:0\r\n    },\r\n    bindPickerChange(e) {\r\n        console.log('picker发送选择改变，携带值为', e.detail.value)\r\n        this.setData({\r\n            index: e.detail.value\r\n        })\r\n    }\r\n})picker组件是一个从底部弹起的滚动选择器，这里我们用它来切换不同评论的排序。每次切换都可以通过 bindchange获得对应的变化，通过 e.detail.value获取用户选择的索引值。官方文档： https://developers.weixin.qq....4、传参跳转写评论页let uriData = {\r\n    logo: \"xxx.jpg\",\r\n    type: \"commentReply\",\r\n    title: \"文章：小程序评论，动态发帖开发指北\\n 作者：智酷方程式\",\r\n    openId:\"xxxxxxxxxxx\",\r\n    replyId:\"aaaaaa\"   //用户回复的是哪个评论的ID\r\n};\r\nwx.navigateTo({ url: `/components/plugins/comment/submit/index?uriData=${encodeURIComponent(JSON.stringify(uriData))}` });这个可以用encodeURIComponent的方式处理下参数中的 中文 ，避免跳转发布评论页接收数据时出现乱码。5、发表评论页显示和控制评论的字数<!-- html部分  关于textarea 的配置 -->\r\n<view class='feedback-cont'>\r\n    <textarea auto-focus=\"true\" value=\"{{replyName}}\" maxlength=\"200\" bindinput=\"textareaCtrl\"\r\n        placeholder-style=\"color:#999;\" placeholder=\"留下评论，共同学习，一起进步\" />\r\n    <view class='fontNum'>{{content.length}}/200</view>\r\n</view>\r\n<view class='feedback-btn' bindtap='commentSubmit'>提交</view>// js部分\r\nPage({\r\n    data: {\r\n        //初始化评论内容，如果是回复则通过传参变成 @xxxx的形式\r\n        content: \"@xxxx\",\r\n    },\r\n    textareaCtrl: function (e) {\r\n        if (e.detail.value) {\r\n            this.setData({\r\n                content: e.detail.value\r\n            })\r\n        } else {\r\n            this.setData({\r\n                content: \"\"\r\n            })\r\n        }\r\n    }\r\n})textarea 在小程序中改动不大，这个标签原有的一些属性都可以继续使用，通过配置maxlength来控制字数，同时，设置auto-focus=\"true\"可以让用户进到这个发表评论页面时自动弹出虚拟键盘和光标定位在输入的区域。当然，也可以将 发表评论 和 评论展示区域 做在一起，这个就要考虑到要么通过“小程序API”获取键盘高度，要么将“发布评论”置顶区域显示，也是可以做的，只是相对考虑的点会多些。当时开发评论组件的时候，考虑开发时间短和用户体验，权衡后，最终决定以上方案，希望能给到大家一些参考和借鉴，在其他组件开发中触类旁通。[代码片段]评论回复组件实战demodemo的微信路径： https://developers.weixin.qq....demo的ID： oHs5cMma7N9W如果你装了IDE工具，可以直接访问上面的demo路径通过代码片段将demo的ID输入进去也可添加：总结，“ 组件化思想 ”对于无论做小程序、react/VUE还是其他项目来说， 减少重复开发，提高复用性 都是一个非常重要的点。 评论功能 其实只要理清楚整体思路，做起来难度并不大，通过一些 原生组件 ，可以大大提高开发效率，同时保证良好的兼容性。后面一期还将分享下功能点较多的 发帖组件 开发。"}
{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pubtime": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "个税计算器 / 微信小程序开发 ", "author": "Rolan", "pubtime": "2019-1-2 00:36", "content": "019年1月1日即将到来，码农们除了关心自己的技能之外，还有薪资是不是可以多拿点。 每次算的时候 都要百度一下个人所得税，但是很多都是老的税率计算，找一个新的出来还是比较麻烦，所以个人开发了一个最新税率的小程序。解决和我有着一样痛苦的码农们的问题。根据最新税改后计算个人所得税的计算器。目前支持南京，后续开放 杭州 上海 北京等城市。 如果有疑问的可以加最下方 开发者微信。首先在微信官网下载微信小程序开发工具 https://mp.weixin.qq.com在https://mp.weixin.qq.com 注册小程序账号，完成个人实名认证。在小程序后台拿到appid，下面就可以开发了。实例查看二维码：先使用weui 小程序ui框架就行页面布局<button block type=\"dark\" bindtap='calculationBindtap'>计算</button>其次写JS代码（计算按钮逻辑代码）import data from './data'\r\n\r\nconst app = getApp;\r\n\r\nPage({\r\n    data: {\r\n        options1: data,\r\n        value: '1',\r\n        checked: true,\r\n        standard: 1,\r\n        marking: 5000,\r\n        beforetaxCount: 0,\r\n        specialitemCount: 0\r\n    },\r\n    \r\n\r\n    calculationBindtap:function(){\r\n        // 开始计算  计算完成把计算结果放在result对象中\r\n        var beforetaxCount = this.data.beforetaxCount;\r\n        var specialitemCount = this.data.specialitemCount;\r\n        var marking = this.data.marking;\r\n        if (beforetaxCount == null || beforetaxCount == 0 || beforetaxCount == ''){\r\n            wx.showToast({\r\n                title: '输入正确薪资',\r\n                mask: true,\r\n                icon: 'loading'\r\n            })\r\n            return;\r\n        }\r\n        if (specialitemCount == null || specialitemCount == ''){\r\n            specialitemCount = 0;\r\n        }\r\n        // 开始计算\r\n\r\n        var oldNum = 0.08;\r\n        var medNum = 0.02;\r\n        var unemNum = 0.005;\r\n        var workNum = 0;\r\n        var giveNum = 0;\r\n\r\n        var providentfundNum = 0.08;\r\n\r\n        var insuranceBase = 19935;\r\n        var providentfundBase = 25300;\r\n\r\n        var oldcount = 0;\r\n        var medcount = 0;\r\n        var unemcount = 0;\r\n        var workcount = 0;\r\n        var givecount = 0;\r\n\r\n        var providentfundcount = 0;\r\n\r\n        var privateFee = 0;\r\n        var plusFee = 0;\r\n\r\n        if(this.data.checked){\r\n            if (parseFloat(beforetaxCount) > parseFloat(insuranceBase)) {\r\n                oldcount = parseFloat(insuranceBase) * parseFloat(oldNum);\r\n                medcount = parseFloat(insuranceBase) * parseFloat(medNum);\r\n                unemcount = parseFloat(insuranceBase) * parseFloat(unemNum);\r\n                workcount = parseFloat(insuranceBase) * parseFloat(workNum);\r\n                givecount = parseFloat(insuranceBase) * parseFloat(giveNum);\r\n            } else {\r\n                oldcount = parseFloat(beforetaxCount) * parseFloat(oldNum);\r\n                medcount = parseFloat(beforetaxCount) * parseFloat(medNum);\r\n                unemcount = parseFloat(beforetaxCount) * parseFloat(unemNum);\r\n                workcount = parseFloat(beforetaxCount) * parseFloat(workNum);\r\n                givecount = parseFloat(beforetaxCount) * parseFloat(giveNum);\r\n            }\r\n\r\n            if (parseFloat(beforetaxCount) > parseFloat(providentfundBase)) {\r\n                providentfundcount = parseFloat(providentfundBase) * parseFloat(providentfundNum);\r\n            } else {\r\n                providentfundcount = parseFloat(beforetaxCount) * parseFloat(providentfundNum);\r\n            }\r\n        }\r\n\r\n        // 保险总费用\r\n        var totalInsuranceFee = parseFloat(oldcount) + parseFloat(medcount) + parseFloat(unemcount) + parseFloat(workcount) + parseFloat(givecount);\r\n        // 公积金费用 \r\n        var totalProvidentfundFee = providentfundcount;\r\n\r\n        // 下面的钱 交税\r\n        console.log(this.data.marking);\r\n        var otherFee = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(this.data.marking) - parseFloat(specialitemCount);\r\n        \r\n        if (parseFloat(otherFee) <= 3000 && parseFloat(otherFee) > 0) {\r\n            privateFee = parseFloat(otherFee) * 0.03;\r\n            plusFee = 0;\r\n        }\r\n        if (parseFloat(otherFee) <= 12000 && parseFloat(otherFee) > 3000) {\r\n            privateFee = parseFloat(otherFee) * 0.1;\r\n            plusFee = 210;\r\n        }\r\n        if (parseFloat(otherFee) <= 25000 && parseFloat(otherFee) > 12000) {\r\n            privateFee = parseFloat(otherFee) * 0.2;\r\n            plusFee = 1410;\r\n        }\r\n        if (parseFloat(otherFee) <= 35000 && parseFloat(otherFee) > 25000) {\r\n            privateFee = parseFloat(otherFee) * 0.25;\r\n            plusFee = 2660;\r\n        }\r\n        if (parseFloat(otherFee) <= 55000 && parseFloat(otherFee) > 35000) {\r\n            privateFee = parseFloat(otherFee) * 0.3;\r\n            plusFee = 4410;\r\n        }\r\n        if (parseFloat(otherFee) <= 80000 && parseFloat(otherFee) > 55000) {\r\n            privateFee = parseFloat(otherFee) * 0.35;\r\n            plusFee = 7160;\r\n        }\r\n        if ( parseFloat(otherFee) > 80000) {\r\n            privateFee = parseFloat(otherFee) * 0.45;\r\n            plusFee = 15160;\r\n        }\r\n\r\n        var result = {};\r\n        \r\n        result.insuranceCount = totalInsuranceFee;\r\n        result.providentfundCount = totalProvidentfundFee;\r\n        result.providentfundNum = parseFloat(providentfundNum) * 100;\r\n        result.money = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(privateFee) + parseFloat(plusFee);\r\n        result.privateFee = privateFee - parseFloat(plusFee);\r\n        result.specialitemCount = specialitemCount;\r\n        result.oldNum = parseFloat(oldNum) * 100;\r\n        result.medNum = parseFloat(medNum) * 100;\r\n        result.unemNum = parseFloat(unemNum) * 100;\r\n        result.workNum = parseFloat(workNum) * 100;\r\n        result.giveNum = parseFloat(giveNum) * 100;\r\n\r\n        result.oldcount = parseFloat(oldcount);\r\n        result.medcount = parseFloat(medcount);\r\n        result.unemcount = parseFloat(unemcount);\r\n        result.workcount = parseFloat(workcount);\r\n        result.givecount = parseFloat(givecount);\r\n\r\n        wx.setStorage({\r\n            key: 'result',\r\n            data: result,\r\n            success:function(){\r\n                wx.navigateTo({\r\n                    url: '../calculation/calculationResult',\r\n                })\r\n            }\r\n        })\r\n        \r\n    },\r\n\r\n})把计算好的结果放在result对象中 通过wx.setStorage 放在缓存中，传到下一个页面。最后展示出来。"}
{"title": "微信小程序开发中遇到的问题及解决办法（一） ", "author": "Rolan", "pubtime": "2019-3-18 00:32", "content": "1、整个页面覆盖的自定义弹窗，滑动弹窗中的内容，页面内容也会滑动。如果快速滚动弹窗，页面内容和弹窗中的内容有时会错乱。这个问题大多出现在苹果手机上，类似事件事件穿透的效果。自定义弹窗截图如下：解决办法：再最外层元素上添加事件： catch:touchmove=\"notDo\"事件代码：/**\r\n   * @desc not do\r\n   */\r\n  notDo: function () {\r\n    // not do\r\n  }wxml截图：注意：加上这个事件后，对侧滑效果有所影响，如果需要侧滑切换页面，建议使用其他方法。2、使用了fixed定位的元素，会出现随页面滚动而移动的现象。社区中的说法大概是：这个是因为小程序架构的原因导致 scroll 事件有一定的延迟，最终使 fixed 的改变不够及时导致的。解决办法：在fixed定位的元素上，添加样式： transform: translate3d(0, 0, 0);3、使用canvas绘制分享图，有的时候绘制错误，导致整张分享图空白。折中解决办法：隐藏canvas，使用html结构，重新渲染分享图。这样方便找出到底是哪里绘制错误倒是整张图绘制不出来，也会有更好的交互效果。还有一点好处，如果分享图只有一屏的内容，可以直接截图分享（如果是苹果，不支持截长图）。注意：如果分享图中并没有大量的动态内容，并不建议使用这种折中方案。因为这需要维护两套代码，而且当html结构渲染出来的时候，canvas可能还未绘制完毕或者绘制错误，会误导用户操作。截图：4、开发者工作模拟小程序不同进入场景，比如：扫描二维码，长按识别二维码的启动参数处理。解决办法：应该通过encodeURIComponent来编码启动参数，在当前页面获取页面参数的时候，再通过decodeURIComponent来解码。截图：代码截图：注意：区别于encodeURI和decodeURI的编解码，encodeURIComponent和decodeURIComponent的组合使用范围更广。encodeURI对在 URI 中具有特殊含义的 ASCII 标点符号，不会进行转义的：;/?:@&=+$,#, 而encodeURIComponent会转义这些。遇上encodeURI不会转义的标点符号，URI会直接被截取掉。随记 ：最近，太阳不再流浪；最近，想遇见更好的自己~"}
{"title": "微信小程序开发之多图片上传+服务端接收 ", "author": "Rolan", "pubtime": "2019-3-19 10:16", "content": "目录导航：前言： 使用技术： wx.chooseImage() 概述： wx.uploadFile()概述： 废话不多说，上代码： .Wxml code： .Js code: 后端图片接收保存 code（.Net WEBAPI） 效果图展示（美女哟，嘻嘻）： 总结：前言：　　业务需求，这次需要做一个小程序同时选中三张图片一起上传到服务端，后端使用的.NET WEBAPI接收数据保存。使用技术：　　在这章中将会使用到微信小程序wx.uploadFile(Object object) 和wx.chooseImage(Object object)接口，对图片大小和来源进行上传wx.chooseImage() 概述： 　　从本地相册选择图片或使用相机拍照，详细了解请阅读微信小程序开发文档（https://developers.weixin.qq.com/miniprogram/dev/api/wx.chooseImage.html?search-key=wx.chooseimage）参数 Object objectwx.uploadFile()概述：　　将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data，详细了解请阅读微信小程序开发文档（https://developers.weixin.qq.com/miniprogram/dev/api/wx.uploadFile.html?q=wx.uploadFile）。参数废话不多说，上代码：.Wxml code： class='form-s2'>门店照片(请选择三张) class=\"weui-uploader__files\" id=\"uploaderFiles\"> wx:for=\"{{files}}\" wx:key=\"*this\"> class=\"weui-uploader__file\" bindtap=\"previewImage\" id=\"{{item}}\" style='margin-top:11px;'> class=\"weui-uploader__img\" src=\"{{item}}\" mode=\"aspectFill\" /> class=\"weui-uploader__input-box\" style='top:11px;'> class=\"weui-uploader__input\" bindtap=\"chooseImage\">.Js code:Page({  /**   * 页面的初始数据   */data:{  files: [], //门店图片信息,数组图片保存作为数据源}，,  /**   * 多图片上传   */chooseImage: function(e) {var that = this;if (that.data.files.length > 2) { resource.notishi(\"抱歉最多只允许上传三张图片哟~\"); return false;}wx.chooseImage({count: 3, //默认9张，这里设置三张sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有success: function(res) {wx.showLoading({title: '上传中,请稍等...',})// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片var tempFilePaths = res.tempFilePaths; //多图片上传，tempFilePaths本地图片地址为一个数组，遍历调用服务器图片上传接口即可实现多图保存for (var i = 0; i < tempFilePaths.length; i++) {console.log('图片地址名称' + tempFilePaths[i]);wx.uploadFile({ url: app.globalData.hostUrl + \"/api/PictureUpload/Upload\", //此处为实际接口地址filePath: tempFilePaths[i], //获取图片路径header: {'content-type': 'multipart/form-data'}, name: 'upload',success: function(res) {wx.hideLoading();let Result = JSON.parse(res.data);console.log(Result);//接收返回来的服务器图片地址if (Result.code == 1) {let picurl = app.globalData.hostUrl + Result.picurl;console.log(picurl); that.setData({files: that.data.files.concat(picurl)});} else { resource.notishi(\"网络异常，请稍后再试\");}},fail: function(res) {wx.hideLoading()wx.showToast({title: '上传失败，请重新上传',icon: 'none',duration: 2000})},})}}})}, //图片预览previewImage: function(e) {wx.previewImage({current: e.currentTarget.id, // 当前显示图片的http链接urls: this.data.files // 需要预览的图片http链接列表})},})后端图片接收保存 code（.Net WEBAPI）/// /// 图片上传保存/// /// [HttpPost]public IHttpActionResult Upload(){ try{var content = Request.Content;//获取http设置的消息和内容var tempUploadFiles = \"/Images/Wechatimages/\";//保存路径var newFileName = \"\";string filePath = \"\";string extname = \"\";string returnurl = \"\";var sp = new MultipartMemoryStreamProvider();Task.Run(async () => await Request.Content.ReadAsMultipartAsync(sp)).Wait();foreach (var item in sp.Contents){if (item.Headers.ContentDisposition.FileName != null){var filename = item.Headers.ContentDisposition.FileName.Replace(\"\\\"\", \"\");FileInfo file = new FileInfo(filename);string fileTypes = \"gif,jpg,jpeg,png,bmp\";if (Array.IndexOf(fileTypes.Split(','), file.Extension.Substring(1).ToLower()) == -1){throw new ApplicationException(\"不支持上传文件类型\");}//获取后缀extname = System.IO.Path.GetExtension(filename);//获取文件的拓展名称newFileName = Guid.NewGuid().ToString().Substring(0, 6) + extname;string newFilePath = DateTime.Now.ToString(\"yyyy-MM-dd\") + \"/\";if (!Directory.Exists(HostingEnvironment.MapPath(\"/\") + tempUploadFiles + newFilePath)){Directory.CreateDirectory(HostingEnvironment.MapPath(\"/\") + tempUploadFiles + newFilePath);}filePath = Path.Combine(HostingEnvironment.MapPath(\"/\") + tempUploadFiles + newFilePath, newFileName); returnurl = Path.Combine(tempUploadFiles + newFilePath, newFileName);//图片相对路径var ms = item.ReadAsStreamAsync().Result;using (var br = new BinaryReader(ms)){var data = br.ReadBytes((int)ms.Length);File.WriteAllBytes(filePath, data);//保存图片}}}return Json(new {code=1,picurl= returnurl,msg=\"success\" }) ;}catch (Exception ex){return Json(new { code =0,msg=ex.Message});}}总结：　　其实做完回过头来想想，无论是微信小程序图片上传还是html页面图片上传原理其实都是差不多，都是通过content-type 为 multipart/form-data 标识，通过http post将图片资源文件以二进制的编码格式传往后台，然后后台获取对应文件流进行数据图片保存。总结的不够到位，有什么没做好的望各位大佬指点。"}
{"title": "微信小程序开发中的代码片段总结 ", "author": "Rolan", "pubtime": "2019-3-22 00:34", "content": "经过一段时间的微信小程序开发，总结了一些代码片段，主要是以下几个方面：小程序（授权、网络、录音、图像）mpvue（分包、全局变量、svg组件、组件class绑定）小程序授权逻辑初次请求 -> 请求用户授权 -> 同意授权(-> 不同意授权 -> 结束) -> 使用对应功能二次请求 -> 跳转小程序设置页面modal -> 设置页面 -> 开启scope -> 使用对应功能const checkPermission = scope =>\r\n  new Promise((resolve, reject) => {\r\n    wx.getSetting({\r\n      success: res => {\r\n        // 是否存在认证配置\r\n        let hasAuthorized = res.authSetting.hasOwnProperty(scope)\r\n        if (hasAuthorized) {\r\n          // 已授权\r\n          if (res.authSetting[scope]) {\r\n            resolve('已授权')\r\n            return\r\n          }\r\n          // 未授权，提示进入小程序设置页面，wx限制:需要主动点击才能执行openSetting()，因此使用modal\r\n          wx.showModal({\r\n            title: '没有权限',\r\n            content: '体验该功能需要您授权功能权限，现在前往设置开启',\r\n            success: res => {\r\n              if (res.confirm) {\r\n                reject('设置页面')\r\n                wx.openSetting()\r\n              } else if (res.cancel) {\r\n                reject('不进入设置')\r\n              }\r\n            }\r\n          })\r\n        }\r\n      },\r\n      fail: err => { reject(err.errMsg) }\r\n    })\r\n  })网络微信小程序不同环境下网络请求的不同之处：校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书\r\n网络请求与拦截器可以使用 fly.js 作为小程序的网络请求库，在使用拦截器等功能时也较为方便。小程序中一个特殊的地方是: content-type 为 multipart/formdata 类型的POST请求不能通过自定义请求的方式发出，需要使用小程序的 wx.uploadFile 方法，可以如下简单封装下：const formDataRequest = (url, filePath, params = {}) =>\r\n  new Promise((resolve, reject) => {\r\n    let token = wx.getStorageSync(\"token\")\r\n    wx.uploadFile({\r\n      url,\r\n      filePath,\r\n      name: \"file\",\r\n      header: { token },\r\n      formData: params,\r\n      success: async res => {\r\n        // 一些对响应数据的处理...\r\n        resolve(res.data)\r\n      },\r\n      fail: err => {\r\n        reject(err)\r\n      }\r\n    });\r\n  });判断是否在线使用 getNetworkType 方法即可export const isOnline = () =>\r\n  new Promise((resolve, reject) => {\r\n    wx.getNetworkType({\r\n      success(res) {\r\n        const networkType = res.networkType\r\n        resolve(networkType !== 'none')\r\n      },\r\n      failed(res) {\r\n        reject(res)\r\n      }\r\n    })\r\n  })录音处理主要是录音时的API检测、状态控制与事件监听器的处理。// 1. 检测录音管理器是否可用\r\nif (wx.getRecorderManager) {\r\n  this.recorder = wx.getRecorderManager()\r\n  this.addRecorderListener()\r\n} else {\r\n  wx.showModal({\r\n    title: '提示',\r\n    showCancel: false,\r\n    content:\r\n      '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'\r\n  })\r\n}\r\n// 2. 录音前检测scope.record授权情况\r\nasync startRecordHandle() {\r\n  if (!this.recorder) return\r\n  try { await this.checkPermission('scope.record') }  \r\n  catch (err) { return }\r\n  this.recorder.start(this.audioOption)\r\n},\r\n// 3. 添加事件监听器\r\naddRecorderListener() {\r\n  if (!this.recorder) return\r\n  this.recorder.onStart(() => {\r\n    ...\r\n    this.recording = true\r\n  })\r\n  this.recorder.onStop(path => {\r\n    ...\r\n    this.recording = false\r\n    this.audioPath = path.tempFilePath\r\n  })\r\n}若需实现长按录音的场景，可以结合 lonepress 事件与 setTimeout 来实现。<template>\r\n  <g-button type=\"primary\"\r\n    ...\r\n    @long-press=\"longPressHandle\"\r\n  />\r\n</template>\r\n<script>\r\nexport default {\r\n  methods: {\r\n    longPressHandle() {\r\n      // longpress事件会在350ms后出发\r\n      this.canRecordStart = true\r\n    },\r\n    touchStartHandle() {\r\n      this.canRecordStart = true\r\n      let delay = 400 // 设置400ms延迟\r\n      setTimeout(() => {\r\n        if (this.canRecordStart) {\r\n          this.startRecordHandle()\r\n        }\r\n      }, delay)\r\n    },\r\n    touchEndHandle() {\r\n      if (!this.canRecordStart) return\r\n      this.canRecordStart = false\r\n      this.stopRecordHandle()\r\n    },\r\n  }\r\n}\r\n</script>图像处理获取图片信息wx.getImageInfo不管是CDN的图片还是本地选择的图片都需要先使用 getImageInfo 获取图片的基本信息getImageInfo(img) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.getImageInfo({\r\n      src: img,\r\n      success: res => { resolve(res) },\r\n      fail: () => { reject('获取图片信息失败') }\r\n    })\r\n  })\r\n}选择图片wx.chooseImage让用户选择本地相册中或拍摄的图片，以选择单张图片为例：const MB = 1024 * 1024\r\nchooseSingleImage() {\r\n  return new Promise((resolve, reject) => {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9，为1获取单张图片\r\n      sizeType: ['original', 'compressed'], // 指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 指定来源是相册还是相机，默认二者都有\r\n      success: res => {\r\n        let file = res.tempFiles[0]\r\n        // 可以对所选图片尺寸或其他属性做一些限制\r\n        // let { size } = file\r\n        // if (size > 20 * MB) { reject('图片大小应小于20MB') }\r\n        resolve(file)\r\n      },\r\n      fail: () => { reject('图片选取失败') }\r\n    })\r\n  })\r\n}读取图片wx.getFileSystemManager()使用小程序的FS相关API读取文件内容readFileInBase64(filePath) {\r\n  return new Promise((resolve, reject) => {\r\n    if (wx.getFileSystemManager) {\r\n      // 以base64编码读取图片\r\n      wx.getFileSystemManager().readFile({\r\n        filePath: filePath,\r\n        encoding: 'base64',\r\n        success: res => { resolve(res) },\r\n        file: () => { reject('读取文件失败') }\r\n      })\r\n    } else {\r\n      // 兼容处理，若不支持则提示更新\r\n      wx.showModal({\r\n        title: '提示',\r\n        showCancel: false,\r\n        content:\r\n          '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'\r\n      })\r\n    }\r\n  })\r\n}Canvas绘制图像小程序中使用CanvasContext API与H5的形式基本相同。需要注意的是，在小程序中绘制canvas时尺寸的单位是 px ，而不是响应式的 rpx 。需要注意的是从基础库 1.9.90 开始 CanvasContext 的API变化了很多，在使用时需要注意兼容性，比如下面两个函数：export const drawPoint = (ctx, x, y) => {\r\n  let pointColor = '#2ba5ff'\r\n  ctx.beginPath()\r\n  ctx.arc(x, y, 1, 0, Math.PI * 2, true)\r\n  ctx.closePath()\r\n  // 兼容画布填充色方法\r\n  if (ctx.fillStyle) {\r\n    // 1.9.90+\r\n    ctx.fillStyle = pointColor\r\n  } else {\r\n    ctx.setFillStyle(pointColor)\r\n  }\r\n  ctx.fill()\r\n}\r\n\r\nexport const drawRect = (ctx, x, y, width, height) => {\r\n  let marginColor = '#ff0000'\r\n  // 兼容笔触色彩方法\r\n  if (ctx.strokeStyle) {\r\n    // 1.9.90+\r\n    ctx.strokeStyle = marginColor\r\n  } else {\r\n    ctx.setStrokeStyle(marginColor)\r\n  }\r\n  ctx.lineWidth = 1\r\n  ctx.strokeRect(x, y, width, height)\r\n}mpvue分包及分包预加载mpvue-loader: ^1.1.2\r\n直接在 app.json 中配置 subPackages 即可:{\r\n  ...\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/module-bob/\",\r\n      \"pages\": [\"subpage-a/main\", \"subpage-b/main\", \"subpage-c/main\"]\r\n    },\r\n    {\r\n      \"root\": \"pages/module-alice/\",\r\n      \"pages\": [\"subpage-d/main\", \"subpage-e/main\", \"subpage-f/main\"]\r\n    }\r\n  ],\r\n  \"preloadRule\": {\r\n    \"pages/index/main\": {\r\n      \"network\": \"wifi\",\r\n      \"packages\": [\"pages/module-bob\"]\r\n    }\r\n  }\r\n  ...\r\n}其中 preloadRule 为预加载配置，上面的设置意为进入index页面时当为wifi网络时预加载module-bob子包。https://segmentfault.com/a/1190000017064732使用globalData全局变量在小程序中将自带的[ globalData ]()挂载到vue的原型方法上。在src中的 main.js 最后添加如下代码:import Vue from 'vue'\r\nimport App from './App'\r\n...\r\nconst app = new Vue(App)\r\napp.$mount()\r\nVue.prototype.$globalData = getApp().globalData // 添加该行然后就可以在其他页面使用该命令操作全局变量了// page A\r\nthis.$globalData.userInfo = {name: 'yrq110'}\r\n// page B\r\nconsole.log(this.$globalData.userInfo)\r\n// page C\r\nthis.$globalData.userInfo.name: 'yrq110'注意，在子页面中使用globalData时，将变量赋值的操作放在data中是无效的，如下:export default {\r\n  data() {\r\n    // 无效\r\n    // isIPX: this.$globalData.isIPX\r\n  },\r\n  computed: {\r\n    isIPX() {\r\n      // 有效\r\n      return this.$globalData.isIPX\r\n    }\r\n  },\r\n}SVG图标组件的默认尺寸与预设尺寸在图标组件中加载svg时使用父标签上的尺寸作为默认尺寸，并在传入特定props参数时使用预设尺寸。业务中碰到了这个问题，使用如下的方法进行了解决：在image组件的load事件处理器中将加载的原始尺寸绑定到style上。实现了： 1. 默认使用svg标签自带尺寸 2. 当传入size属性则使用预设尺寸<template>\r\n  <image\r\n    ...\r\n    @load=\"loadHandle\"\r\n    :style=\"{ width: !size ? iconWidth + 'rpx' : '100%', height: !size ? iconHeight + 'rpx' : '100%'}\"\r\n    ...\r\n  />\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  ...\r\n  data() {\r\n    return {\r\n      iconWidth: 0,\r\n      iconHeight: 0,\r\n      loaded: false // 是否加载完毕\r\n    }\r\n  },\r\n  props: {\r\n    ...\r\n    size: String\r\n  },\r\n  computed: {\r\n    ...\r\n    getSizeClass() {\r\n      let { size } = this\r\n      return size || ''\r\n    },\r\n    setSizeStyle() {\r\n      if (!this.loaded || this.size) return {}\r\n      return {\r\n        width: this.iconWidth + 'rpx',\r\n        height: this.iconHeight + 'rpx'\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    loadHandle(e) {\r\n      this.loaded = true\r\n      // 使用加载后的默认尺寸\r\n      const { detail } = e.mp\r\n      this.iconWidth = detail.width * 2\r\n      this.iconHeight = detail.height * 2\r\n    }\r\n  }\r\n  ...\r\n}\r\n</script>解决无法在组件上绑定class的trick将keyword作为prop属性传入组件并通过Computed属性绑定到class上，这样在外部引用时就可以根据keyword设置自定义的样式了。组件中的关键代码如下：<template>\r\n  <div :class=\"customClass\">\r\n    <slot></slot>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  ...\r\n  props: {\r\n    type: String,\r\n    ...\r\n  },\r\n  computed: {\r\n    customClass() {\r\n      let type = this.type || ''\r\n      return type\r\n    }\r\n  }\r\n  ...\r\n}\r\n</script>在外部引用时就可以使用自定义class来在外部使用样式了:<template>\r\n  ...\r\n  <g-button type=\"custom-button\"></g-button>\r\n  ...\r\n</template>\r\n...\r\n<style lang=\"scss\">\r\n...\r\n.custom-button {\r\n  .text {\r\n    margin-left: 10px;\r\n  }\r\n...\r\n}\r\n</style>"}
{"title": "微信小程序开发早知道 ", "author": "Rolan", "pubtime": "2019-4-4 00:24", "content": "小程序没有跳转公众号、跳转公众号图文素材的能力。除非用户通过扫描二维码进入小程序的情景，可以显示关注公众号组件。公众号菜单、公众号图文素材可以打开小程序，网页无法直接打开小程序。小程序内嵌网页、内嵌网页中跳转链接、iframe 嵌套的页面，都必须在安全域名内，否则无法访问。如果想在小程序内加入第三方广告，要注意这点，因为安全域名修改是有次数限制的，并要求验证服务器。还要注意网页中嵌套 iframe 的情况，例如，网页内嵌了腾讯视频 iframe，由于腾讯视频不在安全域名内，会造成页面无法访问。用户信息授权、手机号码授权需要用户通过点击操作。小程序间跳转需要用户点击操作，跳转前需要用户确认，可跳转小程序数量不超过10个。小程序分为开发版、体验版、审核版、线上版：开发版是开发工具编辑过的最新版本；开发工具上传后成为体验版，具备体验权限的用户都可以查看；将开发版提交给官方审核后，成为审核版；审核成功后，才可以发布成为线上版本。官方「小程序助手」小程序可以很方便打开各版本小程序。每次发布新版本，用户都需要重新下载新版本。小程序仍在不断更新和完善，旧代码可能会因不符合新政策，在下次发布的时候无法正常运行。为避免这种情况的发生，应多关注官方公告。版本回退功能可以将线上版本回退成上一个版本小程序使用 CommonJS 规范，对 ES6 有很好的支持小程序没有官方状态管理工具，页面间通讯靠 query string 传递参数。如果有复杂状态管理的需求的话，建议引入一些设计模式或使用第三方框架。用户微信支付后，需要后台推送消息到服务器，才能确认支付成功。小程序的 DOM 操作只能查询属性，无法设置属性。小程序基础库版本与微信版本有关， 基础库版本与客户端版本对应关系 。小程序也存在兼容性问题，对待不愿更新微信的用户，要像对待忠实的IE6用户一样， 小程序基础库版本分布 。小程序页面只有 onLoad、onShow、onReady、onHide、onUnload 生命周期，没有更新视图相关的生命周期小程序不能直接渲染 HTML string，要用 rich-text 组件，但组件使用 HTML string 性能会有所下降。小程序有很多原生组件，如 Vedio、Map。原生组件位于最上层，会遮挡所有非原生组件，还存在诸多限制，如无法改变大小、无法添加动画效果等等。不过，有些组件在最新版本已经可以同层渲染了。小程序不支持摇一摇功能，但可以通过监听加速度传感器来实现。小程序有官方的广告组件，广告收入官方会抽走一部分。想到再更，欢迎补充."}
{"title": "微信小程序开发——点击按钮退出小程序的实现 ", "author": "Rolan", "pubtime": "2019-4-23 00:43", "content": "微信小程序官方是没有提供退出的API的，但是在navigator这个组件中，是有退出这个功能的：详情参考官方文档：navigator。示例代码：1 <navigator open-type=\"exit\" target=\"miniProgram\">关闭小程序navigator>不过这个功能最低支持版本时 2.1.0 ，如果一定要使用这个功能，那么最好在小程序管理后台中设置最低基础库版本不低于2.1.0，如果对小程序支持的最低基础库低于2.1.0，那么可以对小程序基础库版本进行判断，支持小程序退出的就使用退出组件，如果不支持，那么就做好跳转到其他指定页面的兼容处理。1         wx.getSystemInfo({2           success: function(res) {3             if(res.SDKVersion>=\"2.1.0\"){4               self.setData({5                 exitApp:true//data中的初始化变量6               })7             }8           }9         })1 <navigator wx:if=\"{{exitApp}}\" open-type=\"exit\" target=\"miniProgram\">关闭按钮navigator>2 <navigator wx:else open-type=\"navigate\" target=\"navigate\" url='../../index/index'>返回首页navigator>如果是首页，那么就直接不处理这个返回退出了。注：由于不是API，所以不能使用wx.canIUse(string)的方式进行判断了，所以只能通过获取系统信息的方式获取小程序基础库版本，以此来判断。对于小程序基础库版本分布可以查看官方统计说明：基础库版本分布。"}
{"title": "微信小程序开发需要注意的一些规范 ", "author": "Rolan", "pubtime": "2019-5-5 00:42", "content": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!"}
{"title": "微信小程序开发注意指南和优化实践 ", "author": "Rolan", "pubtime": "2019-6-19 00:40", "content": "前言转眼间已经参与过我厂好几个小程序的开发了，下面本妹子将开发中的那些注意点和各位小伙伴们分享下，妥妥的干货一枚。一、WXML不要换行写，有空格不行微信开发者工具不会对代码进行trim操作，如果代码中换行，页面也直接换行。wx:if vs hidden一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。图片处理1.大图片也会造成页面切换的卡顿有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。 2.图片占容量 代码包限制是2MB，图片占用空间较大，建议都上传到 CDN 上，代码里直接引用链接。 3.大图片小点击位 小程序主要在手机端运行，手机屏幕大小有限，所以尽量点击位大点。 4.图片截取 存在图片没有按原图宽高比例显示，可以设置 image 组件的 mode 属性，来保持原图宽高比。 5.CSSSprites 所有零星图片都包含到一张大图中，减少请求数WXS 模块每个 wxs 模块均有一个内置的 module 对象。 直接在wxml中引入，可以将写需要转化数据的写进去，防止给setData加负担使用了过大的 WXML 节点数目一个太大的WXML节点树会增加内存的使用，样式重排时间也会更长，建议一个页面使用少于 1000 个WXML的节点，节点树深度少于 30 层，子节点数不大于 60 个二、WXSSCss伪类看不到在微信开发者工具中， Styles 不会显示 Css 伪类，喜欢写::before或:first-child的小伙伴们请注意了，你的伪类在控制台是看不到的,所以本妹子不建议在小程序里用 Css 伪类，以防找不到问题点不好修复bug。小程序 button 自带给 after 伪类添加了边框，通过开发者工具是看不到 after ,我们需要自行去掉边框。button::after {\r\n  border: none;\r\n}hover 伪类则可以用小程序自带的属性 hover-class 代替。部分CSS3属性不能用如transform:rotate(180deg)，不能用。自定义颜色限制不是所以颜色配置都能随心所欲，比如导航栏标题颜色，仅支持 black / white；下拉 loading 的样式，仅支持 dark / light。所以出视觉图关注下。滚动区域没有开启惯性滚动当加了overflow: scroll时， IOS 下需要额外设置： -webkit-overflow-scrolling: touch，来开启惯性滚动。三、JSJavaScript 支持情况如果需要支持到 IOS8 话，建议下面 js 方法都不使用。分享事件不支持异步如果你想自定义分享图片，则在生命周期onShareAppMessage中编写如下所示：Page({\r\n  onShareAppMessage: function (res) {\r\n    return {\r\n      title: '自定义转发标题',\r\n      imageUrl: 'https://raoenhui.github.io/images/logo.png'\r\n    }\r\n  }\r\n})但是 onShareAppMessage 不能支持异步，如果你想从接口里获取分享图片URL，必须在 onLoad 提前读取并放入Data中小程序有并发限制wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个。所有为了保险起见，需要写个请求队列，如果并发量大于10，则等待请求。采用公共方法和组件编写公共方法和组件，可以避免重复造轮子。 1.公共埋点方法 2.各种处理js的方法（转https，throttle，formatTime等） 3.公共组件（iphonex兼容组件，倒计时组件等）catch绑定事件比如 catchtouchmove 弹框禁止滑动 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。循环中添加key对于经常要更新的列表需要加上 key 值，key值相当于索引，但是 key 值不要用 index ,因为 index 在增加删除的时候可能不变产生混乱，推荐用唯一标示 id ，对数据改变之后的diff更新比较有很大的性能提升。 PS：如果是单纯只显示的列表，不需要操作更新，那不需要加 key 。巧用nextTick小程序和vue写法比较相似，也有 nextTick ,在当前同步流程结束后，下一个时间片执行 。 比如有些取视图层的数据，可以等页面上流程结束后再取比较准确wx.nextTick(() => {\r\n      query.select('.percent-line-toast').boundingClientRect() \r\n    })处理后台运行的jssetTimeout一定伴随着clearTimeout setInterval一定伴随着clearInterval 这些我们经常会滚动算高度，倒计时，动画中用到。当我跳到了另外一个页面还在运行，小心后台页面的jswx.hide的坑两个都是基于同一个原生toast实例实现的，wx.showLoading()与wx.showToast(), 同时只能显示一个， wx.hideLoading()也会隐藏Toast ; wx.hideToast()也会隐藏Loading， 失败的提示toast会一闪而过的问题，可能时因为调用了wx.hideLoading()。http需变httpsHTTP是明文传输有篡改内容的风险，而且有些安卓机会不兼容。所以我们需要使用https。 所以开需求评审的时候，要注意后端要写成https，如果是运营配的数据，后端最好有个转https方法，输入了url自动转成https链接。在微信开发者工具中，可勾选”不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书”规则即可用http，但是在实体里并没有这个选项，所以建议开发时就用https路径。埋点的坑埋点用公共方法，页面曝光 pv 埋点放入 onshow 生命周期中更加准确。预加载1.数据预加载 上个页面就将接口请求好，存到对象中，下个页面直接从对象中拿，有利有弊，从业务角度出发看是否需要预加载数据 storage也可以存储数据，同一个微信用户，同一个小程序 storage 上限为 10MB。分包预加载preloadRule preloadRule预下载分包行为在进入某个页面时触发，享有共同的预下载大小限额 2M。\"preloadRule\": {\r\n \"sub1/index\": {\r\n   \"packages\": [\"important\"]\r\n }\r\n}3.图片预加载 对视觉效果要求越来越高，多张图片如果想动画显示流畅，可以先加载图片，直接用request先请求图片下来。setData注意点1. 频繁的去 setData存在将未绑定在 WXML 的变量都不需要传入 setData。 2. 每次 setData 都传递大量新数据，可局部更新this.setData({\r\n    list[index] = newList[index]\r\n})3. 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行 setData ，后台态页面的渲染用户是无法感受的，另外后台态页面去 setData 也会抢占前台页面的执行。也就是上文提到的不要忘了 clearTimeout 、 clearInterval 。四、其他使用分包由于小程序包大小有限制，整个小程序所有分包(包括独立分包和普通分包)大小不超过 8M，单个分包/主包大小不能超过 2M，建议把首屏不需要展示的都放入分包中，分包就像H5打出的chunk包一样，可以按需加载。及时清理没有使用到的代码和资源在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。sitemap 配置小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引.单元测试miniprogram-simulate模拟 touch 事件、自定义事件触发 选取子节点 更新自定义组件数据 触发生命周期检测工具开发者工具自带检测评分页面，可以分析页面存在的问题。wxss 覆盖率较低，有些动画样式比如 @keyframes 是检测不到的。以及可以通过性能面板查看页面性能。小伙伴们有其他建议欢迎留言评论^ ^"}
